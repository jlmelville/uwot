<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="description" content="Create a graph (as a sparse symmetric weighted adjacency matrix) representing
the similarities between items in a data set. No dimensionality reduction is
carried out. By default, the similarities are calculated using the merged
fuzzy simplicial set approach in the Uniform Manifold Approximation and
Projection (UMAP) method (McInnes et al., 2018), but the approach from
LargeVis (Tang et al., 2016) can also be used."><title>Similarity Graph — similarity_graph • uwot</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Similarity Graph — similarity_graph"><meta property="og:description" content="Create a graph (as a sparse symmetric weighted adjacency matrix) representing
the similarities between items in a data set. No dimensionality reduction is
carried out. By default, the similarities are calculated using the merged
fuzzy simplicial set approach in the Uniform Manifold Approximation and
Projection (UMAP) method (McInnes et al., 2018), but the approach from
LargeVis (Tang et al., 2016) can also be used."><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light" data-bs-theme="light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">uwot</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1.16.9000</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="nav-item">
  <a class="nav-link" href="../articles/uwot.html">Get started</a>
</li>
<li class="active nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../articles/index.html">Articles</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">Changelog</a>
</li>
      </ul><form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off"></form>

      <ul class="navbar-nav"><li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/jlmelville/uwot/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul></div>

    
  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="" class="logo" alt=""><h1>Similarity Graph</h1>
      <small class="dont-index">Source: <a href="https://github.com/jlmelville/uwot/blob/HEAD/R/uwot.R" class="external-link"><code>R/uwot.R</code></a></small>
      <div class="d-none name"><code>similarity_graph.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>Create a graph (as a sparse symmetric weighted adjacency matrix) representing
the similarities between items in a data set. No dimensionality reduction is
carried out. By default, the similarities are calculated using the merged
fuzzy simplicial set approach in the Uniform Manifold Approximation and
Projection (UMAP) method (McInnes et al., 2018), but the approach from
LargeVis (Tang et al., 2016) can also be used.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">similarity_graph</span><span class="op">(</span></span>
<span>  X <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  n_neighbors <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  metric <span class="op">=</span> <span class="st">"euclidean"</span>,</span>
<span>  scale <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  set_op_mix_ratio <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  local_connectivity <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  nn_method <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  n_trees <span class="op">=</span> <span class="fl">50</span>,</span>
<span>  search_k <span class="op">=</span> <span class="fl">2</span> <span class="op">*</span> <span class="va">n_neighbors</span> <span class="op">*</span> <span class="va">n_trees</span>,</span>
<span>  perplexity <span class="op">=</span> <span class="fl">50</span>,</span>
<span>  method <span class="op">=</span> <span class="st">"umap"</span>,</span>
<span>  y <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  target_n_neighbors <span class="op">=</span> <span class="va">n_neighbors</span>,</span>
<span>  target_metric <span class="op">=</span> <span class="st">"euclidean"</span>,</span>
<span>  target_weight <span class="op">=</span> <span class="fl">0.5</span>,</span>
<span>  pca <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  pca_center <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  ret_extra <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>  n_threads <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  grain_size <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  kernel <span class="op">=</span> <span class="st">"gauss"</span>,</span>
<span>  tmpdir <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/tempfile.html" class="external-link">tempdir</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>  verbose <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/options.html" class="external-link">getOption</a></span><span class="op">(</span><span class="st">"verbose"</span>, <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>  pca_method <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>  binary_edge_weights <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  nn_args <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>
    <dl><dt>X</dt>
<dd><p>Input data. Can be a <code><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></code>, <code><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></code>,
<code><a href="https://rdrr.io/r/stats/dist.html" class="external-link">dist</a></code> object or <code><a href="https://rdrr.io/pkg/Matrix/man/sparseMatrix.html" class="external-link">sparseMatrix</a></code>.
Matrix and data frames should contain one observation per row. Data frames
will have any non-numeric columns removed, although factor columns will be
used if explicitly included via <code>metric</code> (see the help for
<code>metric</code> for details). A sparse matrix is interpreted as a distance
matrix, and is assumed to be symmetric, so you can also pass in an
explicitly upper or lower triangular sparse matrix to save storage. There
must be at least <code>n_neighbors</code> non-zero distances for each row. Both
implicit and explicit zero entries are ignored. Set zero distances you want
to keep to an arbitrarily small non-zero value (e.g. <code>1e-10</code>).
<code>X</code> can also be <code>NULL</code> if pre-computed nearest neighbor data is
passed to <code>nn_method</code>.</p></dd>


<dt>n_neighbors</dt>
<dd><p>The size of local neighborhood (in terms of number of
neighboring sample points) used for manifold approximation. Larger values
result in more global views of the manifold, while smaller values result in
more local data being preserved. In general values should be in the range
<code>2</code> to <code>100</code>.</p></dd>


<dt>metric</dt>
<dd><p>Type of distance metric to use to find nearest neighbors. For
 <code>nn_method = "annoy"</code> this can be one of:</p><ul><li><p><code>"euclidean"</code> (the default)</p></li>
<li><p><code>"cosine"</code></p></li>
<li><p><code>"manhattan"</code></p></li>
<li><p><code>"hamming"</code></p></li>
<li><p><code>"correlation"</code> (a distance based on the Pearson correlation)</p></li>
<li><p><code>"categorical"</code> (see below)</p></li>
</ul><p>For <code>nn_method = "hnsw"</code> this can be one of:</p><ul><li><p><code>"euclidean"</code></p></li>
<li><p><code>"cosine"</code></p></li>
<li><p><code>"correlation"</code></p></li>
</ul><p>If <a href="https://cran.r-project.org/package=rnndescent" class="external-link">rnndescent</a> is
installed and <code>nn_method = "nndescent"</code> is specified then many more
metrics are avaiable, including:</p><ul><li><p><code>"braycurtis"</code></p></li>
<li><p><code>"canberra"</code></p></li>
<li><p><code>"chebyshev"</code></p></li>
<li><p><code>"dice"</code></p></li>
<li><p><code>"hamming"</code></p></li>
<li><p><code>"hellinger"</code></p></li>
<li><p><code>"jaccard"</code></p></li>
<li><p><code>"jensenshannon"</code></p></li>
<li><p><code>"kulsinski"</code></p></li>
<li><p><code>"rogerstanimoto"</code></p></li>
<li><p><code>"russellrao"</code></p></li>
<li><p><code>"sokalmichener"</code></p></li>
<li><p><code>"sokalsneath"</code></p></li>
<li><p><code>"spearmanr"</code></p></li>
<li><p><code>"symmetrickl"</code></p></li>
<li><p><code>"tsss"</code></p></li>
<li><p><code>"yule"</code></p></li>
</ul><p>For more details see the package documentation of <code>rnndescent</code>.
For <code>nn_method = "fnn"</code>, the distance metric is always "euclidean".</p>
<p>If <code>X</code> is a data frame or matrix, then multiple metrics can be
specified, by passing a list to this argument, where the name of each item in
the list is one of the metric names above. The value of each list item should
be a vector giving the names or integer ids of the columns to be included in
a calculation, e.g. <code>metric = list(euclidean = 1:4, manhattan = 5:10)</code>.</p>
<p>Each metric calculation results in a separate fuzzy simplicial set, which are
intersected together to produce the final set. Metric names can be repeated.
Because non-numeric columns are removed from the data frame, it is safer to
use column names than integer ids.</p>
<p>Factor columns can also be used by specifying the metric name
<code>"categorical"</code>. Factor columns are treated different from numeric
columns and although multiple factor columns can be specified in a vector,
each factor column specified is processed individually. If you specify
a non-factor column, it will be coerced to a factor.</p>
<p>For a given data block, you may override the <code>pca</code> and <code>pca_center</code>
arguments for that block, by providing a list with one unnamed item
containing the column names or ids, and then any of the <code>pca</code> or
<code>pca_center</code> overrides as named items, e.g. <code>metric =
list(euclidean = 1:4, manhattan = list(5:10, pca_center = FALSE))</code>. This
exists to allow mixed binary and real-valued data to be included and to have
PCA applied to both, but with centering applied only to the real-valued data
(it is typical not to apply centering to binary data before PCA is applied).</p></dd>


<dt>scale</dt>
<dd><p>Scaling to apply to <code>X</code> if it is a data frame or matrix:</p><ul><li><p><code>"none"</code> or <code>FALSE</code> or <code>NULL</code> No scaling.</p></li>
<li><p><code>"Z"</code> or <code>"scale"</code> or <code>TRUE</code> Scale each column to
  zero mean and variance 1.</p></li>
<li><p><code>"maxabs"</code> Center each column to mean 0, then divide each
  element by the maximum absolute value over the entire matrix.</p></li>
<li><p><code>"range"</code> Range scale the entire matrix, so the smallest
  element is 0 and the largest is 1.</p></li>
<li><p><code>"colrange"</code> Scale each column in the range (0,1).</p></li>
</ul><p>For <code>method</code> <code>"umap"</code>, the default is <code>"none"</code>. For
<code>"largevis"</code>, the default is <code>"maxabs"</code>.</p></dd>


<dt>set_op_mix_ratio</dt>
<dd><p>Interpolate between (fuzzy) union and intersection as
the set operation used to combine local fuzzy simplicial sets to obtain a
global fuzzy simplicial sets. Both fuzzy set operations use the product
t-norm. The value of this parameter should be between <code>0.0</code> and
<code>1.0</code>; a value of <code>1.0</code> will use a pure fuzzy union, while
<code>0.0</code> will use a pure fuzzy intersection. Ignored if
<code>method = "largevis"</code></p></dd>


<dt>local_connectivity</dt>
<dd><p>The local connectivity required -- i.e. the number
of nearest neighbors that should be assumed to be connected at a local
level. The higher this value the more connected the manifold becomes
locally. In practice this should be not more than the local intrinsic
dimension of the manifold. Ignored if <code>method = "largevis"</code>.</p></dd>


<dt>nn_method</dt>
<dd><p>Method for finding nearest neighbors. Options are:</p><ul><li><p><code>"fnn"</code>. Use exact nearest neighbors via the
    <a href="https://cran.r-project.org/package=FNN" class="external-link">FNN</a> package.</p></li>
<li><p><code>"annoy"</code> Use approximate nearest neighbors via the
    <a href="https://cran.r-project.org/package=RcppAnnoy" class="external-link">RcppAnnoy</a> package.</p></li>
<li><p><code>"hnsw"</code> Use approximate nearest neighbors with the
    Hierarchical Navigable Small World (HNSW) method (Malkov and Yashunin,
    2018) via the
    <a href="https://cran.r-project.org/package=RcppHNSW" class="external-link">RcppHNSW</a> package.
    <code>RcppHNSW</code> is not a dependency of this package: this option is
    only available if you have installed <code>RcppHNSW</code> yourself. Also,
    HNSW only supports the following arguments for <code>metric</code> and
    <code>target_metric</code>: <code>"euclidean"</code>, <code>"cosine"</code> and
    <code>"correlation"</code>.</p></li>
<li><p><code>"nndescent"</code> Use approximate nearest neighbors with the
    Nearest Neighbor Descent method (Dong et al., 2011) via the
    <a href="https://cran.r-project.org/package=rnndescent" class="external-link">rnndescent</a>
    package. <code>rnndescent</code> is not a dependency of this package: this
    option is only available if you have installed <code>rnndescent</code>
    yourself.</p></li>
</ul><p>By default, if <code>X</code> has less than 4,096 vertices, the exact nearest
neighbors are found. Otherwise, approximate nearest neighbors are used.
You may also pass pre-calculated nearest neighbor data to this argument. It
must be one of two formats, either a list consisting of two elements:</p><ul><li><p><code>"idx"</code>. A <code>n_vertices x n_neighbors</code> matrix
  containing the integer indexes of the nearest neighbors in <code>X</code>. Each
  vertex is considered to be its own nearest neighbor, i.e.
  <code>idx[, 1] == 1:n_vertices</code>.</p></li>
<li><p><code>"dist"</code>. A <code>n_vertices x n_neighbors</code> matrix
  containing the distances of the nearest neighbors.</p></li>
</ul><p>or a sparse distance matrix of type <code>dgCMatrix</code>, with dimensions
<code>n_vertices x n_vertices</code>. Distances should be arranged by column,
i.e. a non-zero entry in row <code>j</code> of the <code>i</code>th column indicates
that the <code>j</code>th observation in <code>X</code> is a nearest neighbor of the
<code>i</code>th observation with the distance given by the value of that
element.
The <code>n_neighbors</code> parameter is ignored when using precomputed
nearest neighbor data. If using the sparse distance matrix input, each
column can contain a different number of neighbors.</p></dd>


<dt>n_trees</dt>
<dd><p>Number of trees to build when constructing the nearest
neighbor index. The more trees specified, the larger the index, but the
better the results. With <code>search_k</code>, determines the accuracy of the
Annoy nearest neighbor search. Only used if the <code>nn_method</code> is
<code>"annoy"</code>. Sensible values are between <code>10</code> to <code>100</code>.</p></dd>


<dt>search_k</dt>
<dd><p>Number of nodes to search during the neighbor retrieval. The
larger k, the more the accurate results, but the longer the search takes.
With <code>n_trees</code>, determines the accuracy of the Annoy nearest neighbor
search. Only used if the <code>nn_method</code> is <code>"annoy"</code>.</p></dd>


<dt>perplexity</dt>
<dd><p>Used only if <code>method = "largevis"</code>. Controls the size
of the local neighborhood used for manifold approximation. Should be a
value between 1 and one less than the number of items in <code>X</code>. If
specified, you should <em>not</em> specify a value for <code>n_neighbors</code>
unless you know what you are doing.</p></dd>


<dt>method</dt>
<dd><p>How to generate the similarities between items. One of:</p><ul><li><p><code>"umap"</code> The UMAP method of McInnes et al. (2018).</p></li>
<li><p><code>"largevis"</code> The LargeVis method of Tang et al. (2016).</p></li>
</ul></dd>


<dt>y</dt>
<dd><p>Optional target data to add supervised or semi-supervised weighting
  to the similarity graph . Can be a vector, matrix or data frame. Use the
  <code>target_metric</code> parameter to specify the metrics to use, using the
  same syntax as <code>metric</code>. Usually either a single numeric or factor
  column is used, but more complex formats are possible. The following types
  are allowed:</p><ul><li><p>Factor columns with the same length as <code>X</code>. <code>NA</code> is
    allowed for any observation with an unknown level, in which case
    UMAP operates as a form of semi-supervised learning. Each column is
    treated separately.</p></li>
<li><p>Numeric data. <code>NA</code> is <em>not</em> allowed in this case. Use the
    parameter <code>target_n_neighbors</code> to set the number of neighbors used
    with <code>y</code>. If unset, <code>n_neighbors</code> is used. Unlike factors,
    numeric columns are grouped into one block unless <code>target_metric</code>
    specifies otherwise. For example, if you wish columns <code>a</code> and
    <code>b</code> to be treated separately, specify
    <code>target_metric = list(euclidean = "a", euclidean = "b")</code>. Otherwise,
    the data will be effectively treated as a matrix with two columns.</p></li>
<li><p>Nearest neighbor data, consisting of a list of two matrices,
    <code>idx</code> and <code>dist</code>. These represent the precalculated nearest
    neighbor indices and distances, respectively. This
    is the same format as that expected for precalculated data in
    <code>nn_method</code>. This format assumes that the underlying data was a
    numeric vector. Any user-supplied value of the <code>target_n_neighbors</code>
    parameter is ignored in this case, because the the number of columns in
    the matrices is used for the value. Multiple nearest neighbor data using
    different metrics can be supplied by passing a list of these lists.</p></li>
</ul><p>Unlike <code>X</code>, all factor columns included in <code>y</code> are automatically
used. This parameter is ignored if <code>method = "largevis"</code>.</p></dd>


<dt>target_n_neighbors</dt>
<dd><p>Number of nearest neighbors to use to construct the
target simplicial set. Default value is <code>n_neighbors</code>. Applies only if
<code>y</code> is non-<code>NULL</code> and <code>numeric</code>.  This parameter is ignored
if <code>method = "largevis"</code>.</p></dd>


<dt>target_metric</dt>
<dd><p>The metric used to measure distance for <code>y</code> if
using supervised dimension reduction. Used only if <code>y</code> is numeric.
This parameter is ignored if <code>method = "largevis"</code>.</p></dd>


<dt>target_weight</dt>
<dd><p>Weighting factor between data topology and target
topology. A value of 0.0 weights entirely on data, a value of 1.0 weights
entirely on target. The default of 0.5 balances the weighting equally
between data and target. Only applies if <code>y</code> is non-<code>NULL</code>. This
parameter is ignored if <code>method = "largevis"</code>.</p></dd>


<dt>pca</dt>
<dd><p>If set to a positive integer value, reduce data to this number of
columns using PCA. Doesn't applied if the distance <code>metric</code> is
<code>"hamming"</code>, or the dimensions of the data is larger than the
number specified (i.e. number of rows and columns must be larger than the
value of this parameter). If you have &gt; 100 columns in a data frame or
matrix, reducing the number of columns in this way may substantially
increase the performance of the nearest neighbor search at the cost of a
potential decrease in accuracy. In many t-SNE applications, a value of 50
is recommended, although there's no guarantee that this is appropriate for
all settings.</p></dd>


<dt>pca_center</dt>
<dd><p>If <code>TRUE</code>, center the columns of <code>X</code> before
carrying out PCA. For binary data, it's recommended to set this to
<code>FALSE</code>.</p></dd>


<dt>ret_extra</dt>
<dd><p>A vector indicating what extra data to return. May contain
any combination of the following strings:</p><ul><li><p><code>"nn"</code> nearest neighbor data that can be used as input to
    <code>nn_method</code> to avoid the overhead of repeatedly calculating the
    nearest neighbors when manipulating unrelated parameters. See the
    "Value" section for the names of the list items. Note that the nearest
    neighbors could be sensitive to data scaling, so be wary of reusing
    nearest neighbor data if modifying the <code>scale</code> parameter.</p></li>
<li><p><code>"sigma"</code> the normalization value for each observation in the
    dataset when constructing the smoothed distances to each of its
    neighbors. This gives some sense of the local density of each
    observation in the high dimensional space: higher values of
    <code>sigma</code> indicate a higher dispersion or lower density.</p></li>
</ul></dd>


<dt>n_threads</dt>
<dd><p>Number of threads to use. Default is half the number of
concurrent threads supported by the system. For nearest neighbor search,
only applies if <code>nn_method = "annoy"</code>. If <code>n_threads &gt; 1</code>, then
the Annoy index will be temporarily written to disk in the location
determined by <code><a href="https://rdrr.io/r/base/tempfile.html" class="external-link">tempfile</a></code>.</p></dd>


<dt>grain_size</dt>
<dd><p>The minimum amount of work to do on each thread. If this
value is set high enough, then less than <code>n_threads</code> will be used for
processing, which might give a performance improvement if the overhead of
thread management and context switching was outweighing the improvement due
to concurrent processing. This should be left at default (<code>1</code>) and
work will be spread evenly over all the threads specified.</p></dd>


<dt>kernel</dt>
<dd><p>Used only if <code>method = "largevis"</code>. Type of kernel
function to create input similiarties. Can be one of <code>"gauss"</code> (the
default) or <code>"knn"</code>. <code>"gauss"</code> uses the usual Gaussian weighted
similarities. <code>"knn"</code> assigns equal similiarties. to every edge in the
nearest neighbor graph, and zero otherwise, using <code>perplexity</code> nearest
neighbors. The <code>n_neighbors</code> parameter is ignored in this case.</p></dd>


<dt>tmpdir</dt>
<dd><p>Temporary directory to store nearest neighbor indexes during
nearest neighbor search. Default is <code><a href="https://rdrr.io/r/base/tempfile.html" class="external-link">tempdir</a></code>. The index is
only written to disk if <code>n_threads &gt; 1</code> and
<code>nn_method = "annoy"</code>; otherwise, this parameter is ignored.</p></dd>


<dt>verbose</dt>
<dd><p>If <code>TRUE</code>, log details to the console.</p></dd>


<dt>pca_method</dt>
<dd><p>Method to carry out any PCA dimensionality reduction when
the <code>pca</code> parameter is specified. Allowed values are:</p><ul><li><p><code>"irlba"</code>. Uses <code><a href="https://rdrr.io/pkg/irlba/man/prcomp_irlba.html" class="external-link">prcomp_irlba</a></code> from the
  <a href="https://cran.r-project.org/package=irlba" class="external-link">irlba</a> package.</p></li>
<li><p><code>"rsvd"</code>. Uses 5 iterations of <code><a href="https://rdrr.io/pkg/irlba/man/svdr.html" class="external-link">svdr</a></code> from
  the <a href="https://cran.r-project.org/package=irlba" class="external-link">irlba</a> package.
  This is likely to give much faster but potentially less accurate results
  than using <code>"irlba"</code>. For the purposes of nearest neighbor
  calculation and coordinates initialization, any loss of accuracy doesn't
  seem to matter much.</p></li>
<li><p><code>"bigstatsr"</code>. Uses <code><a href="https://privefl.github.io/bigstatsr/reference/big_randomSVD.html" class="external-link">big_randomSVD</a></code>
  from the <a href="https://cran.r-project.org/package=bigstatsr" class="external-link">bigstatsr</a>
  package. The SVD methods used in <code>bigstatsr</code> may be faster on
  systems without access to efficient linear algebra libraries (e.g.
  Windows). <strong>Note</strong>: <code>bigstatsr</code> is <em>not</em> a dependency of
  uwot: if you choose to use this package for PCA, you <em>must</em> install
  it yourself.</p></li>
<li><p><code>"svd"</code>. Uses <code><a href="https://rdrr.io/r/base/svd.html" class="external-link">svd</a></code> for the SVD. This is
  likely to be slow for all but the smallest datasets.</p></li>
<li><p><code>"auto"</code> (the default). Uses <code>"irlba"</code>, unless more than
  50<!-- % of the full set of singular vectors would be calculated, in which -->
  case <code>"svd"</code> is used.</p></li>
</ul></dd>


<dt>binary_edge_weights</dt>
<dd><p>If <code>TRUE</code> then edge weights of the returned
graph are binary (0/1) rather than reflecting the degree of similarity.</p></dd>


<dt>nn_args</dt>
<dd><p>A list containing additional arguments to pass to the nearest
neighbor method. For <code>nn_method = "annoy"</code>, you can specify
<code>"n_trees"</code> and <code>"search_k"</code>, and these will override the
<code>n_trees</code> and <code>search_k</code> parameters.
For <code>nn_method = "hnsw"</code>, you may specify the following arguments:</p><ul><li><p><code>M</code> The maximum number of neighbors to keep for each vertex.
Reasonable values are <code>2</code> to <code>100</code>. Higher values give better
recall at the cost of more memory. Default value is <code>16</code>.</p></li>
<li><p><code>ef_construction</code> A positive integer specifying the size of
the dynamic list used during index construction. A higher value will
provide better results at the cost of a longer time to build the index.
Default is <code>200</code>.</p></li>
<li><p><code>ef</code> A positive integer specifying the size of the dynamic
list used during search. This cannot be smaller than <code>n_neighbors</code>
and cannot be higher than the number of items in the index. Default is
<code>10</code>.</p></li>
</ul><p>For <code>nn_method = "nndescent"</code>, you may specify the following
arguments:</p><ul><li><p><code>n_trees</code> The number of trees to use in a random projection
forest to initialize the search. A larger number will give more accurate
results at the cost of a longer computation time. The default of
<code>NULL</code> means that the number is chosen based on the number of
observations in <code>X</code>.</p></li>
<li><p><code>max_candidates</code> The number of potential neighbors to explore
per iteration. By default, this is set to <code>n_neighbors</code> or <code>60</code>,
whichever is smaller. A larger number will give more accurate results at
the cost of a longer computation time.</p></li>
<li><p><code>n_iters</code> The number of iterations to run the search. A larger
number will give more accurate results at the cost of a longer computation
time. By default, this will be chosen based on the number of observations
in <code>X</code>. You may also need to modify the convergence criterion
<code>delta</code>.</p></li>
<li><p><code>delta</code> The minimum relative change in the neighbor graph
allowed before early stopping. Should be a value between 0 and 1. The
smaller the value, the smaller the amount of progress between iterations is
allowed. Default value of <code>0.001</code> means that at least 0.1<!-- % of the -->
neighbor graph must be updated at each iteration.</p></li>
<li><p><code>init</code> How to initialize the nearest neighbor descent. By
default this is set to <code>"tree"</code> and uses a random project forest.
If you set this to <code>"rand"</code>, then a random selection is used. Usually
this is less accurate than using RP trees, but for high-dimensional cases,
there may be little difference in the quality of the initialization and
random initialization will be a lot faster. If you set this to
<code>"rand"</code>, then the <code>n_trees</code> parameter is ignored.</p></li>
<li><p><code>pruning_degree_multiplier</code> The maximum number of edges per node
to retain in the search graph, relative to <code>n_neighbors</code>. A larger
value will give more accurate results at the cost of a longer computation
time. Default is <code>1.5</code>. This parameter only affects neighbor search
when transforming new data with <code><a href="umap_transform.html">umap_transform</a></code>.</p></li>
<li><p><code>epsilon</code> Controls the degree of the back-tracking when
traversing the search graph. Setting this to <code>0.0</code> will do a greedy
search with no back-tracking. A larger value will give more accurate
results at the cost of a longer computation time. Default is <code>0.1</code>.
This parameter only affects neighbor search when transforming new data with
<code><a href="umap_transform.html">umap_transform</a></code>.</p></li>
<li><p><code>max_search_fraction</code> Specifies the maximum fraction of the
search graph to traverse. By default, this is set to <code>1.0</code>, so the
entire graph (i.e. all items in <code>X</code>) may be visited. You may want to
set this to a smaller value if you have a very large dataset (in
conjunction with <code>epsilon</code>) to avoid an inefficient exhaustive search
of the data in <code>X</code>. This parameter only affects neighbor search when
transforming new data with <code><a href="umap_transform.html">umap_transform</a></code>.</p></li>
</ul></dd>

</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    

<p>A sparse symmetrized matrix of the similarities between the items in</p>
<p></p>
<p><code>X</code> or if <code>nn_method</code> contains pre-computed nearest neighbor
  data, the items in <code>nn_method</code>. Because of the symmetrization, there
  may be more non-zero items in each column than the specified value of</p>
<p></p>
<p><code>n_neighbors</code> (or pre-computed neighbors in <code>nn_method</code>).
  If <code>ret_extra</code> is specified then the return value will be a list
  containing:</p>
<p></p>
<ul><li><p><code>similarity_graph</code> the similarity graph as a sparse matrix
    as described above.</p></li>
<li><p><code>nn</code> (if <code>ret_extra</code> contained <code>"nn"</code>) the nearest
    neighbor data as a list called <code>nn</code>. This contains one list for each
    <code>metric</code> calculated, itself containing a matrix <code>idx</code> with the
    integer ids of the neighbors; and a matrix <code>dist</code> with the
    distances. The <code>nn</code> list (or a sub-list) can be used as input to the
    <code>nn_method</code> parameter.</p></li>
<li><p><code>sigma</code> (if <code>ret_extra</code> contains <code>"sigma"</code>),
    a vector of calibrated parameters, one for each item in the input data,
    reflecting the local data density for that item. The exact definition of
    the values depends on the choice of the <code>method</code> parameter.</p></li>
<li><p><code>rho</code> (if <code>ret_extra</code> contains <code>"sigma"</code>), a
    vector containing the largest distance to the locally connected neighbors
    of each item in the input data. This will exist only if
    <code>method = "umap"</code>.</p></li>
<li><p><code>localr</code> (if <code>ret_extra</code> contains <code>"localr"</code>) a
    vector of the estimated local radii, the sum of <code>"sigma"</code> and
    <code>"rho"</code>. This will exist only if <code>method = "umap"</code>.</p></li>
</ul></div>
    <div class="section level2">
    <h2 id="details">Details<a class="anchor" aria-label="anchor" href="#details"></a></h2>
    <p>This is equivalent to running <code><a href="umap.html">umap</a></code> with the
<code>ret_extra = c("fgraph")</code> parameter, but without the overhead of
calculating (or returning) the optimized low-dimensional coordinates.</p>
    </div>
    <div class="section level2">
    <h2 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a></h2>
    <p>Dong, W., Moses, C., &amp; Li, K. (2011, March).
Efficient k-nearest neighbor graph construction for generic similarity measures.
In <em>Proceedings of the 20th international conference on World Wide Web</em>
(pp. 577-586).
ACM.
<a href="https://doi.org/10.1145/1963405.1963487" class="external-link">doi:10.1145/1963405.1963487</a>
.</p>
<p>Malkov, Y. A., &amp; Yashunin, D. A. (2018).
Efficient and robust approximate nearest neighbor search using hierarchical
navigable small world graphs.
<em>IEEE transactions on pattern analysis and machine intelligence</em>, <em>42</em>(4), 824-836.</p>
<p>McInnes, L., Healy, J., &amp; Melville, J. (2018).
UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction
<em>arXiv preprint</em> <em>arXiv</em>:1802.03426.
<a href="https://arxiv.org/abs/1802.03426" class="external-link">https://arxiv.org/abs/1802.03426</a></p>
<p>Tang, J., Liu, J., Zhang, M., &amp; Mei, Q. (2016, April).
Visualizing large-scale and high-dimensional data.
In <em>Proceedings of the 25th International Conference on World Wide Web</em>
(pp. 287-297).
International World Wide Web Conferences Steering Committee.
<a href="https://arxiv.org/abs/1602.00370" class="external-link">https://arxiv.org/abs/1602.00370</a></p>
    </div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span></span></span>
<span class="r-in"><span><span class="va">iris30</span> <span class="op">&lt;-</span> <span class="va">iris</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">10</span>, <span class="fl">51</span><span class="op">:</span><span class="fl">60</span>, <span class="fl">101</span><span class="op">:</span><span class="fl">110</span><span class="op">)</span>, <span class="op">]</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># return a 30 x 30 sparse matrix with similarity data based on 10 nearest</span></span></span>
<span class="r-in"><span><span class="co"># neighbors per item</span></span></span>
<span class="r-in"><span><span class="va">iris30_sim_graph</span> <span class="op">&lt;-</span> <span class="fu">similarity_graph</span><span class="op">(</span><span class="va">iris30</span>, n_neighbors <span class="op">=</span> <span class="fl">10</span><span class="op">)</span></span></span>
<span class="r-in"><span></span></span>
<span class="r-in"><span><span class="co"># Default is to use the UMAP method of calculating similarities, but LargeVis</span></span></span>
<span class="r-in"><span><span class="co"># is also available: for that method, use perplexity instead of n_neighbors</span></span></span>
<span class="r-in"><span><span class="co"># to control neighborhood size. Use ret_extra = "nn" to return nearest</span></span></span>
<span class="r-in"><span><span class="co"># neighbor data as well as the similarity graph. Return value is a list</span></span></span>
<span class="r-in"><span><span class="co"># containing similarity_graph' and 'nn' items.</span></span></span>
<span class="r-in"><span><span class="va">iris30_lv_graph</span> <span class="op">&lt;-</span> <span class="fu">similarity_graph</span><span class="op">(</span><span class="va">iris30</span>,</span></span>
<span class="r-in"><span>  perplexity <span class="op">=</span> <span class="fl">10</span>,</span></span>
<span class="r-in"><span>  method <span class="op">=</span> <span class="st">"largevis"</span>, ret_extra <span class="op">=</span> <span class="st">"nn"</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="co"># If you have the neighbor information you don't need the original data</span></span></span>
<span class="r-in"><span><span class="va">iris30_lv_graph_nn</span> <span class="op">&lt;-</span> <span class="fu">similarity_graph</span><span class="op">(</span></span></span>
<span class="r-in"><span>  nn_method <span class="op">=</span> <span class="va">iris30_lv_graph</span><span class="op">$</span><span class="va">nn</span>,</span></span>
<span class="r-in"><span>  perplexity <span class="op">=</span> <span class="fl">10</span>, method <span class="op">=</span> <span class="st">"largevis"</span></span></span>
<span class="r-in"><span><span class="op">)</span></span></span>
<span class="r-in"><span><span class="fu"><a href="https://rdrr.io/r/base/all.html" class="external-link">all</a></span><span class="op">(</span><span class="va">iris30_lv_graph_nn</span> <span class="op">==</span> <span class="va">iris30_lv_graph</span><span class="op">$</span><span class="va">similarity_graph</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> [1] TRUE</span>
<span class="r-in"><span></span></span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p></p><p>Developed by James Melville.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.8.</p>
</div>

    </footer></div>

  

  

  </body></html>

