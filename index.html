<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="An implementation of the Uniform Manifold Approximation and
    Projection dimensionality reduction by McInnes et al. (2018)
    &lt;arXiv:1802.03426&gt;. It also provides means to transform new data and
    to carry out supervised dimensionality reduction. An implementation of
    the related LargeVis method of Tang et al. (2016) &lt;arXiv:1602.00370&gt;
    is also provided. This is a complete re-implementation in R (and C++,
    via the Rcpp package): no Python installation is required. See the
    uwot website (&lt;https://github.com/jlmelville/uwot&gt;) for more
    documentation and examples.">
<title>The Uniform Manifold Approximation and Projection (UMAP) Method for
    Dimensionality Reduction • uwot</title>
<script src="deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="pkgdown.js"></script><meta property="og:title" content="The Uniform Manifold Approximation and Projection (UMAP) Method for
    Dimensionality Reduction">
<meta property="og:description" content="An implementation of the Uniform Manifold Approximation and
    Projection dimensionality reduction by McInnes et al. (2018)
    &lt;arXiv:1802.03426&gt;. It also provides means to transform new data and
    to carry out supervised dimensionality reduction. An implementation of
    the related LargeVis method of Tang et al. (2016) &lt;arXiv:1602.00370&gt;
    is also provided. This is a complete re-implementation in R (and C++,
    via the Rcpp package): no Python installation is required. See the
    uwot website (&lt;https://github.com/jlmelville/uwot&gt;) for more
    documentation and examples.">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light"><div class="container">
    
    <a class="navbar-brand me-2" href="index.html">uwot</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1.16.9000</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="reference/index.html">Reference</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="articles/index.html">Articles</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="news/index.html">Changelog</a>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/jlmelville/uwot/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-home">
<div class="row">
  <main id="main" class="col-md-9"><div class="section level1">
<div class="page-header"><h1 id="uwot">uwot<a class="anchor" aria-label="anchor" href="#uwot"></a>
</h1></div>
<!-- badges: start -->

<p>An R implementation of the <a href="https://arxiv.org/abs/1802.03426" class="external-link">Uniform Manifold Approximation and Projection (UMAP)</a> method for dimensionality reduction (McInnes et al. 2018), that also implements the supervised and metric (out-of-sample) learning extensions to the basic method. Translated from the <a href="https://github.com/lmcinnes/umap" class="external-link">Python implementation</a>.</p>
<div class="section level2">
<h2 id="news">News<a class="anchor" aria-label="anchor" href="#news"></a>
</h2>
<p><em>June 28 2023</em> Version 0.1.16 has been released to CRAN. This is a very minor tweak to 0.1.15 to further support the new release of <a href="https://cran.r-project.org/package=RcppAnnoy" class="external-link">RcppAnnoy</a>.</p>
<p><em>June 26 2023</em> Version 0.1.15 has been released to CRAN. This is to support a new release of <a href="https://cran.r-project.org/package=RcppAnnoy" class="external-link">RcppAnnoy</a>, but there are also some bug fixes and other minor improvements. There are some new functions: <code>optimize_graph_layout</code> will carry out the UMAP optimization step on a sparse similiarity matrix, e.g. the output of <code>similarity_graph</code>. <code>simplicial_set_union</code> and <code>simplicial_set_intersect</code> provide ways to merge different views of the same data into one sparse similiarity matrix. As usual, <code>NEWS.md</code> has all the details.</p>
<p><em>August 22 2022</em> Just when you least expected it, version 0.1.14 has been released to CRAN (the <code>NEWS</code> file on CRAN calls it <code>0.1.13.9000</code> because I forgot to update that file, but let’s keep that amongst ourselves). This release includes a bug fix for <code>umap_transform</code> when you use external nearest neighbors and new function <code>similarity_graph</code>, to support extracting just the high dimensional fuzzy simplicial set.</p>
<p><em>August 16 2022</em> Version 0.1.13 has been released to CRAN (0.1.12 was a failed submission). Among other things you can now pass your own nearest neighbors data in sparse matrix form. Also there is an option to reproduce relative cluster density by <a href="https://jlmelville.github.io/uwot/leopold.html">approximating the densMAP method</a>. See the <a href="https://github.com/jlmelville/uwot/blob/master/NEWS.md#uwot-0113" class="external-link">NEWS</a> page for more.</p>
<p><em>December 12 2021</em> Version 0.1.11 has been released to CRAN. It is now possible to get reproducible results (for a given value of <code>set.seed</code>) when running the optimization step with multiple threads (<code>n_sgd_threads</code> greater than 1). You may need to increase <code>n_epochs</code> to get similar levels of convergence. To run in this mode, set <code>batch = TRUE</code>. Thanks to <a href="https://github.com/LTLA" class="external-link">Aaron Lun</a> who came up with the design for this and also implemented it in his <a href="https://github.com/LTLA/umappp" class="external-link">umappp C++ library</a>. See <code>NEWS.md</code> for other changes.</p>
<p><em>December 15 2020</em> Version 0.1.10 has been released to CRAN. This is mainly to maintain compatibility with RcppAnnoy, but also a small change was made to avoid it grinding away pointlessly in the presence of <code>NA</code> values, based on an observation by <a href="https://twitter.com/David_McGaughey/status/1328389091239501824" class="external-link">David McGaughey on Twitter</a>.</p>
<p><em>November 15 2020</em> Version 0.1.9 has been released to CRAN. The main addition is support for the Pearson correlation. Also, a slight license change from GPL-3 to GPL-3 or later.</p>
<p><em>August 1 2020</em> New metric supported: Pearson correlation (with <code>metric = "correlation"</code>). This should give similar results to the Python UMAP (and sklearn) implementation of the <code>correlation</code> metric.</p>
<p><em>March 16 2020</em> A new version (0.1.8) is on CRAN. This is a minor release in terms of features, but you can now export the UMAP graph (<a href="https://github.com/jlmelville/uwot/issues/47" class="external-link uri">https://github.com/jlmelville/uwot/issues/47</a>), and there are some bug fixes for: loading Annoy indexes (<a href="https://github.com/jlmelville/uwot/issues/31" class="external-link uri">https://github.com/jlmelville/uwot/issues/31</a>), reproducibility across platforms (<a href="https://github.com/jlmelville/uwot/issues/46" class="external-link uri">https://github.com/jlmelville/uwot/issues/46</a>) and we no longer use RcppParallel for the multi-threading support, which should lead to fewer installation problems.</p>
<p><em>March 4 2020</em> I had to cancel my submission of version 0.1.7 to CRAN because of a broken example in a library using uwot. In the mean time I have switched to using <code>std::thread</code> rather than tinythread++.</p>
<p><em>March 1 2020</em> Version 0.1.6 was rejected from CRAN due to undefined behavior issues that originate from RcppAnnoy and RcppParallel. I am hopeful that the Annoy behavior is fixed and a suitable version of RcppAnnoy will be released onto CRAN eventually. The RcppParallel issues originate with the use of <a href="https://github.com/intel/tbb" class="external-link">tbb</a> and seems much harder to deal with. As there is no way to use RcppParallel without tbb yet, I am temporarily replacing the use of RcppParallel with just a subset of the code needed to run parallel for loops with the <a href="https://tinythreadpp.bitsnbites.eu/" class="external-link">tinythread++</a> library.</p>
<p><em>December 4 2019</em> Version 0.1.5 released on CRAN. This fixes a couple of crash bugs, including one where the R API was being called from inside a thread. This may have been causing the issues seen by users of <a href="https://github.com/cole-trapnell-lab/monocle3/issues/186" class="external-link">monocle</a> and <a href="https://github.com/satijalab/seurat/issues/2256" class="external-link">seurat</a>.</p>
<p><em>September 23 2019</em> Version 0.1.4 released on CRAN. This ensures compatibility with RcppAnnoy 0.0.13 when using <code>load_uwot</code>.</p>
<p><em>April 6 2019</em>. uwot is now on <a href="https://cran.r-project.org/package=uwot" class="external-link">CRAN</a>. Also, some minor-to-horrible bugs in the <code>lvish</code> perplexity routine have been fixed.</p>
<p>For visualization purposes, it seems reasonable to use the old PRNG (<code>pcg_rand = FALSE</code>), along with multiple threads during SGD (<code>n_sgd_threads = "auto"</code>), and the UMAP gradient approximation (<code>approx_pow = TRUE</code>), which combined will show a very noticeable speed up during optimization. I have added a new parameter, <code>fast_sgd</code>, which if set to <code>TRUE</code>, sets these options for you.</p>
</div>
<div class="section level2">
<h2 id="installing">Installing<a class="anchor" aria-label="anchor" href="#installing"></a>
</h2>
<div class="section level3">
<h3 id="from-cran">From CRAN<a class="anchor" aria-label="anchor" href="#from-cran"></a>
</h3>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/install.packages.html" class="external-link">install.packages</a></span><span class="op">(</span><span class="st">"uwot"</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="from-github">From github<a class="anchor" aria-label="anchor" href="#from-github"></a>
</h3>
<p><code>uwot</code> makes use of C++ code which must be compiled. You may have to carry out a few extra steps before being able to build this package:</p>
<p><strong>Windows</strong>: install <a href="https://cran.r-project.org/bin/windows/Rtools/" class="external-link">Rtools</a> and ensure <code>C:\Rtools\bin</code> is on your path.</p>
<p><strong>Mac OS X</strong>: using a custom <code>~/.R/Makevars</code> <a href="https://github.com/jlmelville/uwot/issues/1" class="external-link">may cause linking errors</a>. This sort of thing is a potential problem on all platforms but seems to bite Mac owners more. <a href="https://cran.r-project.org/bin/macosx/RMacOSX-FAQ.html#Installation-of-source-packages" class="external-link">The R for Mac OS X FAQ</a> may be helpful here to work out what you can get away with. To be on the safe side, I would advise building <code>uwot</code> without a custom <code>Makevars</code>.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/install.packages.html" class="external-link">install.packages</a></span><span class="op">(</span><span class="st">"remotes"</span><span class="op">)</span></span>
<span><span class="fu">remotes</span><span class="fu">::</span><span class="fu">install_github</span><span class="op">(</span><span class="st">"jlmelville/uwot"</span><span class="op">)</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="example">Example<a class="anchor" aria-label="anchor" href="#example"></a>
</h2>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/jlmelville/uwot" class="external-link">uwot</a></span><span class="op">)</span></span>
<span></span>
<span><span class="co"># See function man page for help</span></span>
<span><span class="op">?</span><span class="va">umap</span></span>
<span></span>
<span><span class="co"># Non-numeric columns are ignored, so in a lot of cases you can pass a data</span></span>
<span><span class="co"># frame directly to umap</span></span>
<span><span class="va">iris_umap</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/umap.html">umap</a></span><span class="op">(</span><span class="va">iris</span>, n_neighbors <span class="op">=</span> <span class="fl">50</span>, learning_rate <span class="op">=</span> <span class="fl">0.5</span>, init <span class="op">=</span> <span class="st">"random"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Load mnist from somewhere, e.g.</span></span>
<span><span class="co"># devtools::install_github("jlmelville/snedata")</span></span>
<span><span class="co"># mnist &lt;- snedata::download_mnist()</span></span>
<span><span class="va">mnist_umap</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/umap.html">umap</a></span><span class="op">(</span><span class="va">mnist</span>, n_neighbors <span class="op">=</span> <span class="fl">15</span>, min_dist <span class="op">=</span> <span class="fl">0.001</span>, verbose <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># For high dimensional datasets (&gt; 100-1000 columns) using PCA to reduce</span></span>
<span><span class="co"># dimensionality is highly recommended to avoid the nearest neighbor search</span></span>
<span><span class="co"># taking a long time. Keeping only 50 dimensions can speed up calculations</span></span>
<span><span class="co"># without affecting the visualization much</span></span>
<span><span class="va">mnist_umap</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/umap.html">umap</a></span><span class="op">(</span><span class="va">mnist</span>, pca <span class="op">=</span> <span class="fl">50</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Use a specific number of threads</span></span>
<span><span class="va">mnist_umap</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/umap.html">umap</a></span><span class="op">(</span><span class="va">mnist</span>, n_neighbors <span class="op">=</span> <span class="fl">15</span>, min_dist <span class="op">=</span> <span class="fl">0.001</span>, verbose <span class="op">=</span> <span class="cn">TRUE</span>, n_threads <span class="op">=</span> <span class="fl">8</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Use a different metric</span></span>
<span><span class="va">mnist_umap_cosine</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/umap.html">umap</a></span><span class="op">(</span><span class="va">mnist</span>, n_neighbors <span class="op">=</span> <span class="fl">15</span>, metric <span class="op">=</span> <span class="st">"cosine"</span>, min_dist <span class="op">=</span> <span class="fl">0.001</span>, verbose <span class="op">=</span> <span class="cn">TRUE</span>, n_threads <span class="op">=</span> <span class="fl">8</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># If you are only interested in visualization, `fast_sgd = TRUE` gives a much faster optimization</span></span>
<span><span class="va">mnist_umap_fast_sgd</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/umap.html">umap</a></span><span class="op">(</span><span class="va">mnist</span>, n_neighbors <span class="op">=</span> <span class="fl">15</span>, metric <span class="op">=</span> <span class="st">"cosine"</span>, min_dist <span class="op">=</span> <span class="fl">0.001</span>, verbose <span class="op">=</span> <span class="cn">TRUE</span>, fast_sgd <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Supervised dimension reduction</span></span>
<span><span class="va">mnist_umap_s</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/umap.html">umap</a></span><span class="op">(</span><span class="va">mnist</span>, n_neighbors <span class="op">=</span> <span class="fl">15</span>, min_dist <span class="op">=</span> <span class="fl">0.001</span>, verbose <span class="op">=</span> <span class="cn">TRUE</span>, n_threads <span class="op">=</span> <span class="fl">8</span>,</span>
<span>                     y <span class="op">=</span> <span class="va">mnist</span><span class="op">$</span><span class="va">Label</span>, target_weight <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Add new points to an existing embedding</span></span>
<span><span class="va">mnist_train</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">mnist</span>, <span class="fl">60000</span><span class="op">)</span></span>
<span><span class="va">mnist_test</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">tail</a></span><span class="op">(</span><span class="va">mnist</span>, <span class="fl">10000</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># You must set ret_model = TRUE to return extra data we need</span></span>
<span><span class="co"># coordinates are in mnist_train_umap$embedding</span></span>
<span><span class="va">mnist_train_umap</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/umap.html">umap</a></span><span class="op">(</span><span class="va">mnist_train</span>, verbose <span class="op">=</span> <span class="cn">TRUE</span>, ret_model <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">mnist_test_umap</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/umap_transform.html">umap_transform</a></span><span class="op">(</span><span class="va">mnist_test</span>, <span class="va">mnist_train_umap</span>, verbose <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Save the nearest neighbor data</span></span>
<span><span class="va">mnist_nn</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/umap.html">umap</a></span><span class="op">(</span><span class="va">mnist</span>, ret_nn <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co"># coordinates are now in mnist_nn$embedding</span></span>
<span></span>
<span><span class="co"># Re-use the nearest neighor data and save a lot of time</span></span>
<span><span class="va">mnist_nn_spca</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/umap.html">umap</a></span><span class="op">(</span><span class="va">mnist</span>, nn_method <span class="op">=</span> <span class="va">mnist_nn</span><span class="op">$</span><span class="va">nn</span>, init <span class="op">=</span> <span class="st">"spca"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># No problem to have ret_nn = TRUE and ret_model = TRUE at the same time</span></span>
<span><span class="co"># Or just use the ret_extra parameter:</span></span>
<span><span class="va">mnist_nn_and_model</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/umap.html">umap</a></span><span class="op">(</span><span class="va">mnist</span>, ret_extra <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"model"</span>, <span class="st">"nn"</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># You can also get to the input fuzzy graph as a sparse matrix via "fgraph"</span></span>
<span><span class="va">mnist_with_fgraph</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/umap.html">umap</a></span><span class="op">(</span><span class="va">mnist</span>, ret_extra <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"fgraph"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co"># equivalent for lvish is to use "P" (input probability matrix):</span></span>
<span><span class="va">mnist_with_P</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/lvish.html">lvish</a></span><span class="op">(</span><span class="va">mnist</span>, ret_extra <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"P"</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Calculate Petal and Sepal neighbors separately (uses intersection of the resulting sets):</span></span>
<span><span class="va">iris_umap</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/umap.html">umap</a></span><span class="op">(</span><span class="va">iris</span>, metric <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="st">"euclidean"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Sepal.Length"</span>, <span class="st">"Sepal.Width"</span><span class="op">)</span>,</span>
<span>                                      <span class="st">"euclidean"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Petal.Length"</span>, <span class="st">"Petal.Width"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co"># Can also use individual factor columns</span></span>
<span><span class="va">iris_umap</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/umap.html">umap</a></span><span class="op">(</span><span class="va">iris</span>, metric <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="st">"euclidean"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Sepal.Length"</span>, <span class="st">"Sepal.Width"</span><span class="op">)</span>,</span>
<span>                                      <span class="st">"euclidean"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Petal.Length"</span>, <span class="st">"Petal.Width"</span><span class="op">)</span>,</span>
<span>                                      <span class="st">"categorical"</span> <span class="op">=</span> <span class="st">"Species"</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Batch mode allows for multiple threads while being reproducible</span></span>
<span><span class="co"># (at the cost of needing more epochs for larger datasets)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">42</span><span class="op">)</span></span>
<span><span class="va">iris_umap_batch</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/umap.html">umap</a></span><span class="op">(</span><span class="va">iris</span>, batch <span class="op">=</span> <span class="cn">TRUE</span>, n_sgd_threads <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span><span class="co"># This will give the same results</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">42</span><span class="op">)</span></span>
<span><span class="va">iris_umap_batch2</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/umap.html">umap</a></span><span class="op">(</span><span class="va">iris</span>, batch <span class="op">=</span> <span class="cn">TRUE</span>, n_sgd_threads <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/all.html" class="external-link">all</a></span><span class="op">(</span><span class="va">iris_umap_batch</span> <span class="op">==</span> <span class="va">iris_umap_batch2</span><span class="op">)</span></span>
<span><span class="co"># TRUE</span></span>
<span></span>
<span><span class="co"># Batch mode uses Adam optimizer by default. Control the parameters with the opt_args list</span></span>
<span><span class="va">iris_umap_batch</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/umap.html">umap</a></span><span class="op">(</span><span class="va">iris</span>, batch <span class="op">=</span> <span class="cn">TRUE</span>, opt_args <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>beta1 <span class="op">=</span> <span class="fl">0.9</span>, beta2 <span class="op">=</span> <span class="fl">0.999</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="documentation">Documentation<a class="anchor" aria-label="anchor" href="#documentation"></a>
</h2>
<p><a href="https://jlmelville.github.io/uwot" class="uri">https://jlmelville.github.io/uwot</a>.</p>
</div>
<div class="section level2">
<h2 id="a-note-on-reproducibility">A Note on Reproducibility<a class="anchor" aria-label="anchor" href="#a-note-on-reproducibility"></a>
</h2>
<p><code>uwot</code> relies on the underlying compiler and C++ standard library on your machine and this can result in differences in output even with the same input data, arguments, packages and R version. If you require reproducibility between machines, it is strongly suggested that you stick with the same OS and compiler version on all of them (e.g. a fixed LTS of a Linux distro and gcc version). Otherwise, the following can help:</p>
<ul>
<li>Use the <code>tumap</code> method instead of <code>umap</code>. This avoid the use of <code>std::pow</code> in gradient calculations. This also has the advantage of being faster to optimize. However, this gives larger clusters in the output, and you don’t have the ability to control that with <code>a</code> and <code>b</code> (or <code>spread</code> and <code>min_dist</code>) parameters.</li>
<li>For <code>umap</code>, it’s better to provide <code>a</code> and <code>b</code> directly with a fixed precision rather than allowing them to be calculated via the <code>spread</code> and <code>min_dist</code> parameters. For default UMAP, use <code>a = 1.8956, b = 0.8006</code>.</li>
<li>Use <code>approx_pow = TRUE</code>, which avoids the use of the <code>std::pow</code> function.</li>
<li>Use <code>init = "spca"</code> rather than <code>init = "spectral"</code> (although the latter is the default and preferred method for UMAP initialization).</li>
</ul>
<p>In summary, your chances of reproducibility are increased by using:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mnist_umap</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/umap.html">umap</a></span><span class="op">(</span><span class="va">mnist</span>, a <span class="op">=</span> <span class="fl">1.8956</span>, b <span class="op">=</span> <span class="fl">0.8006</span>, approx_pow <span class="op">=</span> <span class="cn">TRUE</span>, init <span class="op">=</span> <span class="st">"spca"</span><span class="op">)</span></span>
<span><span class="co"># or</span></span>
<span><span class="va">mnist_tumap</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/tumap.html">tumap</a></span><span class="op">(</span><span class="va">mnist</span>, init <span class="op">=</span> <span class="st">"spca"</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="implementation-details">Implementation Details<a class="anchor" aria-label="anchor" href="#implementation-details"></a>
</h2>
<p>For small (N &lt; 4096) and Euclidean distance, exact nearest neighbors are found using the <a href="https://cran.r-project.org/package=FNN" class="external-link">FNN</a> package. Otherwise, approximate nearest neighbors are found using <a href="https://cran.r-project.org/package=RcppAnnoy" class="external-link">RcppAnnoy</a>. The supported distance metrics (set by the <code>metric</code> parameter) are:</p>
<ul>
<li>Euclidean</li>
<li>Cosine</li>
<li>Pearson Correlation (<code>correlation</code>)</li>
<li>Manhattan</li>
<li>Hamming</li>
</ul>
<p>Exactly what constitutes the cosine distance can differ between packages. <code>uwot</code> tries to follow how the Python version of UMAP defines it, which is 1 minus the cosine similarity. This differs slightly from how Annoy defines its angular distance, so be aware that <code>uwot</code> internally converts the Annoy version of the distance. Also be aware that the Pearson correlation distance is the cosine distance applied to row-centered vectors.</p>
<p>If you need other metrics, and can generate the nearest neighbor info externally, you can pass the data directly to <code>uwot</code> via the <code>nn_method</code> parameter. See the <a href="https://github.com/jlmelville/uwot#nearest-neighbor-data-format" class="external-link">Nearest Neighbor Data Format section</a> for more details. Please note that the Hamming support is a lot slower than the other metrics. I do not recommend using it if you have more than a few hundred features, and even then expect it to take several minutes during the index building phase in situations where the Euclidean metric would take only a few seconds.</p>
<p>Coordinate initialization uses <a href="https://cran.r-project.org/package=RSpectra" class="external-link">RSpectra</a> to do the eigendecomposition of the normalized Laplacian.</p>
<p>The optional PCA initialization and initial dimensionality reduction uses <a href="https://cran.r-project.org/package=irlba" class="external-link">irlba</a>.</p>
<p>The smooth k-nearest neighbor distance and stochastic gradient descent optimization routines are written in C++ (using <a href="https://cran.r-project.org/package=Rcpp" class="external-link">Rcpp</a>, aping the Python code as closely as possible. It is my first time using Rcpp, so let’s assume I did a horrible job.</p>
<p>For the datasets I’ve tried it with, the results look at least reminiscent of those obtained using the <a href="https://github.com/lmcinnes/umap" class="external-link">official Python implementation</a>. Below are results for the 70,000 MNIST digits (downloaded using the <a href="https://github.com/jlmelville/snedata" class="external-link">snedata</a> package). On the left is the result of using the official Python UMAP implementation (via the <a href="https://cran.r-project.org/package=reticulate" class="external-link">reticulate</a> package). The right hand image is the result of using <code>uwot</code>.</p>
<table class="table">
<colgroup>
<col width="51%">
<col width="48%">
</colgroup>
<tbody><tr class="odd">
<td><img src="reference/figures/readme/mnist-py.png" alt="mnist-py.png"></td>
<td><img src="reference/figures/readme/mnist-r.png" alt="mnist-r.png"></td>
</tr></tbody>
</table>
<p>The project documentation contains some more <a href="https://jlmelville.github.io/uwot/umap-examples.html">examples</a>.</p>
</div>
<div class="section level2">
<h2 id="performance">Performance<a class="anchor" aria-label="anchor" href="#performance"></a>
</h2>
<p><em>December 31 2018</em> Updated timings, keeping better track of versions numbers.</p>
<p>To get a feel for the performance of <code>uwot</code>, here are some timings for processing the MNIST dataset, compared with some other methods. I wouldn’t take them very seriously, but they show that <code>uwot</code> is competitive with other methods.</p>
<table class="table">
<colgroup>
<col width="28%">
<col width="25%">
<col width="32%">
<col width="14%">
</colgroup>
<thead><tr class="header">
<th>Package</th>
<th>Version</th>
<th>Arguments</th>
<th>Time</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><a href="https://cran.r-project.org/package=Rtsne" class="external-link">Rtsne</a></td>
<td><a href="https://github.com/jkrijthe/Rtsne/commit/f3f42504eeac627e4d886b1489ee289f8f9d082b" class="external-link">0.15</a></td>
<td><code>partial_pca = TRUE</code></td>
<td>14m 13s</td>
</tr>
<tr class="even">
<td><a href="https://github.com/pavlin-policar/openTSNE" class="external-link">openTSNE (Python)</a></td>
<td>0.3.0-py37h830ac7b_1000</td>
<td><code>n_jobs=4</code></td>
<td>6m 4s</td>
</tr>
<tr class="odd">
<td><a href="https://github.com/pavlin-policar/openTSNE" class="external-link">openTSNE (Python)</a></td>
<td>0.3.0-py37h830ac7b_1000</td>
<td><code>n_jobs=4, negative_gradient_method="bh"</code></td>
<td>17m 56s</td>
</tr>
<tr class="even">
<td><a href="https://github.com/KlugerLab/FIt-SNE" class="external-link">FIt-SNE (C++)</a></td>
<td><a href="https://github.com/KlugerLab/FIt-SNE/releases/download/v1.0.0/FItSNE-Windows-1.0.0.zip" class="external-link">1.0.0</a></td>
<td><code>nthreads = 4</code></td>
<td>2m 43s</td>
</tr>
<tr class="odd">
<td><a href="https://github.com/KlugerLab/FIt-SNE" class="external-link">FIt-SNE (C++)</a></td>
<td><a href="https://github.com/KlugerLab/FIt-SNE/releases/download/v1.0.0/FItSNE-Windows-1.0.0.zip" class="external-link">1.0.0</a></td>
<td>
<code>nthreads = 4</code> + PCA to 50D</td>
<td>1m 11s</td>
</tr>
<tr class="even">
<td><a href="https://github.com/lferry007/LargeVis" class="external-link">LargeVis (C++)</a></td>
<td><a href="https://github.com/lferry007/LargeVis/commit/feb8121e8eb9652477f7f564903d189ee663796f" class="external-link">feb8121</a></td>
<td><code>-threads 4</code></td>
<td>12m 43s</td>
</tr>
<tr class="odd">
<td><a href="https://github.com/elbamos/largevis" class="external-link">largeVis (R package)</a></td>
<td><a href="https://github.com/elbamos/largeVis/commit/e51871e689642177c184527efab668d248717fa9" class="external-link">e51871e</a></td>
<td><code>save_neighbors = FALSE, save_edges = FALSE, threads = 4</code></td>
<td>33m 58s</td>
</tr>
<tr class="even">
<td><code><a href="reference/lvish.html">uwot::lvish</a></code></td>
<td><a href="https://github.com/jlmelville/uwot/releases/tag/v0.0.0.9009" class="external-link">0.0.0.9009</a></td>
<td><code>n_threads = 4, n_sgd_threads = 4</code></td>
<td>5m 52s</td>
</tr>
<tr class="odd">
<td><a href="https://github.com/lmcinnes/umap" class="external-link">UMAP (Python)</a></td>
<td>0.3.7-py37_1000</td>
<td></td>
<td>1m 25s</td>
</tr>
<tr class="even">
<td><a href="https://cran.r-project.org/package=umap" class="external-link">umap (R package)</a></td>
<td><a href="https://github.com/tkonopka/umap/commit/09f60205c572fc1fbfa3e985b48572098fc9b17d" class="external-link">09f6020</a></td>
<td><code>method = "naive"</code></td>
<td>9m 14s</td>
</tr>
<tr class="odd">
<td>uwot</td>
<td><a href="https://github.com/jlmelville/uwot/releases/tag/v0.0.0.9009" class="external-link">0.0.0.9009</a></td>
<td><code>n_threads = 0</code></td>
<td>3m 11s</td>
</tr>
<tr class="even">
<td>uwot</td>
<td><a href="https://github.com/jlmelville/uwot/releases/tag/v0.0.0.9009" class="external-link">0.0.0.9009</a></td>
<td><code>n_threads = 4</code></td>
<td>2m 0s</td>
</tr>
<tr class="odd">
<td>uwot</td>
<td><a href="https://github.com/jlmelville/uwot/releases/tag/v0.0.0.9009" class="external-link">0.0.0.9009</a></td>
<td><code>n_threads = 4, approx_pow = TRUE</code></td>
<td>1m 24s</td>
</tr>
<tr class="even">
<td>uwot</td>
<td><a href="https://github.com/jlmelville/uwot/releases/tag/v0.0.0.9009" class="external-link">0.0.0.9009</a></td>
<td><code>n_threads = 4, approx_pow = TRUE, n_sgd_threads = 4</code></td>
<td>1m 16s</td>
</tr>
<tr class="odd">
<td>uwot</td>
<td><a href="https://github.com/jlmelville/uwot/releases/tag/v0.0.0.9009" class="external-link">0.0.0.9009</a></td>
<td><code>n_threads = 4, approx_pow = TRUE, pca = 50</code></td>
<td>48s</td>
</tr>
</tbody>
</table>
<p>Some notes on how these numbers were generated: I ran this on a Windows machine, using R 3.5.2 and Python 3.7.0. The official LargeVis implementation was built with Visual Studio 2017 Community Edition and may not be properly optimized (the VS solution is available in <a href="https://github.com/jlmelville/LargeVis" class="external-link">my fork</a>).</p>
<p>For R packages, the MNIST data was downloaded via the <a href="https://github.com/jlmelville/snedata" class="external-link">snedata</a> package. For Python packages, the <code>sklearn.datasets.fetch_mldata('MNIST original')</code> was used. The LargeVis source code contains a MNIST example with the data already present.</p>
<p>For FIt-SNE, I used the <a href="https://github.com/KlugerLab/FIt-SNE/releases/download/v1.0.0/FItSNE-Windows-1.0.0.zip" class="external-link">provided Windows binary</a> via the R wrapper (and hence used the MNIST data from the <code>snedata</code> package). The reported time for second FIt-SNE entry in the table and includes the 13 seconds it takes to reduce the dimensionality to 50 via PCA, using <a href="https://cran.r-project.org/package=irlba" class="external-link">irlba</a> (this is the same package and dimension reduction used by Rtsne and the last reported time for uwot).</p>
<p>The default openTSNE uses the same FFT approach that FIt-SNE does, so I don’t know why it’s much slower, apart from the use of the numpy version of FFT rather than the <a href="http://www.fftw.org/" class="external-link">FFTW</a> library, but my understanding was that it shouldn’t make much difference with a dataset the size of MNIST. Perhaps this is a Windows thing.</p>
<p>For <code>uwot</code>, the bottleneck with typical settings is the nearest neighbor search, which is currently provided by Annoy, whereas the Python implementation uses <a href="https://github.com/lmcinnes/pynndescent" class="external-link">pynndescent</a>, a nearest neighbor descent approach.</p>
<p>On the optimization side of things, <code>uwot</code> defaults are conservative. Using <code>approx_pow = TRUE</code> uses the <code>fastPrecisePow</code> approximation to the <code>pow</code> function suggested by <a href="https://martin.ankerl.com/2012/01/25/optimized-approximative-pow-in-c-and-cpp/" class="external-link">Martin Ankerl</a>. For what I think seem like typical values of <code>b</code> (between <code>0.7</code> and <code>0.9</code>) and the squared distance (<code>0</code>-<code>1000</code>), I found the maximum relative error was about <code>0.06</code>. However, I haven’t done much testing, beyond looking to see that results from the <a href="https://jlmelville.github.io/uwot/umap-examples.html">examples page</a> are not obviously worsened. Results in the table above with <code>approx_pow = TRUE</code> do show a worthwhile improvement.</p>
<p>Using <code>n_sgd_threads</code> with more than 1 thread will not give reproducible results, but should not behave any worse than LargeVis in that regard, so for many visualization needs, this is also worth trying.</p>
</div>
<div class="section level2">
<h2 id="memory-usage">Memory Usage<a class="anchor" aria-label="anchor" href="#memory-usage"></a>
</h2>
<p>By the deeply unscientific method of me looking at how much memory the R session was taking up according to the Task Manager, processing MNIST with four threads saw the memory usage increase by nearly 1 GB at some points. There are some manual calls to <code><a href="https://rdrr.io/r/base/gc.html" class="external-link">gc()</a></code> after some stages to avoid holding onto unused memory for longer than usual. The larger the value of <code>n_neighbors</code>, the more memory you can expect to take up (see, for example, the discussion of the <code>lvish</code> function below).</p>
</div>
<div class="section level2">
<h2 id="multi-threading-support">Multi-threading support<a class="anchor" aria-label="anchor" href="#multi-threading-support"></a>
</h2>
<p><a href="https://github.com/RcppCore/RcppParallel" class="external-link">RcppParallel</a> is used for the nearest neighbor index search, the smooth knn/perplexity calibration, and the optimization, which is the same approach that <a href="https://github.com/lferry007/LargeVis" class="external-link">LargeVis</a> takes.</p>
<p>You can (and should) adjust the number of threads via the <code>n_threads</code>, which controls the nearest neighbor and smooth knn calibration, and the <code>n_sgd_threads</code> parameter, which controls the number of threads used during optimization. For the <code>n_threads</code>, the default is half of whatever RcppParallel thinks should be the default. For <code>n_sgd_threads</code> the default is <code>0</code>, which ensures reproducibility of results with a fixed seed.</p>
<p>I have also exposed the <code>grain_size</code> parameter. If a thread would process less than <code>grain_size</code> number of items, then no multithreading is carried out.</p>
<p>I’ve not experienced any problems with using multiple threads for a little while, but if you have any problems with crashing sessions, please file an issue.</p>
</div>
<div class="section level2">
<h2 id="limitations-and-other-issues">Limitations and Other Issues<a class="anchor" aria-label="anchor" href="#limitations-and-other-issues"></a>
</h2>
<ul>
<li>As noted in the <a href="https://github.com/jlmelville/uwot#implementation-details" class="external-link">Implementation Details</a>, only Euclidean, Cosine, Hamming, Pearson Correlation, and Manhattan distances are supported for finding nearest neighbors from data frame and dense matrix input. For other metrics, you can pass nearest neighbor data directly: see the <a href="https://github.com/jlmelville/uwot#nearest-neighbor-data-format" class="external-link">Nearest Neighbor Data Format</a> section. Or if you can calculate a distance matrix for your data, you can pass it in as <code>dist</code> object. For larger distance matrices, you can pass in a <code>sparseMatrix</code> (from the <a href="https://cran.r-project.org/package=Matrix" class="external-link">Matrix</a> package). Neither approach is supremely efficient at the moment. Proper sparse matrix support is limited by the nearest neighbor search routine: Annoy is intended for dense vectors. Adding a library for sparse nearest neighbor search would be a good extension.</li>
<li>If <code>n_sgd_threads</code> is set larger than <code>1</code>, then even if you use <code>set.seed</code>, results of the embeddings are not repeatable, This is because there is no locking carried out on the underlying coordinate matrix, and work is partitioned by edge not vertex and a given vertex may be processed by different threads. The order in which reads and writes occur is of course at the whim of the thread scheduler. This is the same behavior as largeVis.</li>
<li>I haven’t applied <code>uwot</code> on anything much larger than MNIST and Fashion MNIST (so at least around 100,000 rows with 500-1,000 columns works fine). Bear in mind that Annoy itself says it works best with dimensions &lt; 100, but still works “surprisingly well” up to 1000.</li>
<li>Experience with <a href="http://www.cs.columbia.edu/CAVE/software/softlib/coil-100.php" class="external-link">COIL-100</a>, which has 49,152 features, suggests that Annoy will <em>definitely</em> struggle with datasets of this dimensionality. I strongly recommend using the <code>pca</code> option to reduce the dimensionality, e.g <code>pca = 100</code>.</li>
<li>The spectral initialization default for <code>umap</code> (and the Laplacian Eigenmap initialization, <code>init = "laplacian"</code>) can sometimes run into problems. If it fails to converge it will fall back to random initialization, but on occasion I’ve seen it take an extremely long time (a couple of hours) to converge. Recent changes have hopefully reduced the chance of this happening, but if initialization is taking more than a few minutes, I suggest stopping the calculation and using the scaled PCA (<code>init = "spca"</code>) instead.</li>
<li>
<code>R CMD check</code> currently reports the following note: <code>GNU make is a SystemRequirements.</code>, which is expected and due to using RcppParallel. On Linux, it sometimes notes that the <code>libs</code> sub-directory is over 1 MB. I am unsure if this is anything to worry about.</li>
</ul>
</div>
<div class="section level2">
<h2 id="other-methods">Other Methods<a class="anchor" aria-label="anchor" href="#other-methods"></a>
</h2>
<p>Some other dimensionality reduction methods are also available in <code>uwot</code>:</p>
<div class="section level3">
<h3 id="t-umap">t-UMAP<a class="anchor" aria-label="anchor" href="#t-umap"></a>
</h3>
<p>If you choose the UMAP curve parameters to be <code>a = 1</code> and <code>b = 1</code>, you get back the Cauchy distribution used in <a href="https://lvdmaaten.github.io/tsne/" class="external-link">t-Distributed Stochastic Neighbor Embedding</a> and <a href="https://arxiv.org/abs/1602.00370" class="external-link">LargeVis</a>. This also happens to significantly simplify the gradient leading to a noticeable speed-up: for MNIST, I saw the optimization time drop from 66 seconds to 18 seconds. The trade off is that you will see larger, more spread-out clusters than with the typical UMAP settings (they’re still more compact than you see in t-SNE, however). To try t-UMAP, use the <code>tumap</code> function:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mnist_tumap</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/tumap.html">tumap</a></span><span class="op">(</span><span class="va">mnist</span>, n_neighbors <span class="op">=</span> <span class="fl">15</span>, verbose <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p>Note that using <code>umap(a = 1, b = 1)</code> doesn’t use the simplified gradient, so you won’t see any speed-up that way.</p>
</div>
<div class="section level3">
<h3 id="lvish-a-largevis-ish-method">lvish: a LargeVis-ish method<a class="anchor" aria-label="anchor" href="#lvish-a-largevis-ish-method"></a>
</h3>
<p>As UMAP’s implementation is similar to LargeVis in some respects, this package also offers a LargeVis-like method, <code>lvish</code>:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># perplexity, init and n_epoch values shown are the defaults</span></span>
<span><span class="co"># use perplexity instead of n_neighbors to control local neighborhood size</span></span>
<span><span class="va">mnist_lv</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/lvish.html">lvish</a></span><span class="op">(</span><span class="va">mnist</span>, perplexity <span class="op">=</span> <span class="fl">50</span>, init <span class="op">=</span> <span class="st">"lvrand"</span>, n_epochs <span class="op">=</span> <span class="fl">5000</span>,</span>
<span>                  verbose <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co"># Make hilarious Lembas bread joke</span></span></code></pre></div>
<p>Although <code>lvish</code> is like the real LargeVis in terms of the input weights, output weight function and gradient, and so should give results that resemble the real thing, note that:</p>
<ul>
<li>Like the real LargeVis, matrix input data is normalized by centering each column and then the entire matrix is scaled by dividing by the maximum absolute value. This differs from <code>umap</code>, where no scaling is carried out. Scaling can be controlled by the <code>scale</code> parameter.</li>
<li>Nearest neighbor results are not refined via the neighbor expansion method. The <code>search_k</code> parameter is twice as large than Annoy’s default to compensate.</li>
<li>The other nearest neighbor index parameter, <code>n_trees</code>, is not dynamically chosen based on data set size. In LargeVis, it ranges between 10 (for N &lt; 100,000) and 100 (for N &gt; 5,000,000). The <code>lvish</code> default of 50 would cover datasets up to N = 5,000,000, and combined with the default <code>search_k</code>, seems suitable for the datasets I’ve looked at.</li>
<li>Negative edges are generated by uniform sampling of vertexes rather than their degree ^ 0.75.</li>
<li>The default number of epochs is dataset-dependent, to generate the same number of edge samples that would be used by the default settings of the reference LargeVis implementation. This normally results in a substantially longer run time than for <code>umap</code>. You may be able to get away with fewer epochs, and using the UMAP initialization of <code>init = "spectral"</code>, rather than the default Gaussian random initialization (<code>init = "lvrand"</code>) can help.</li>
</ul>
<p>The left-hand image below is the result of running the official LargeVis implementation on MNIST. The image on the right is that from running <code>lvish</code> with its default settings (apart from setting <code>n_threads = 8</code>). Given they were both initialized from different random configurations, there’s no reason to believe they would be identical, but they look pretty similar:</p>
<table class="table">
<colgroup>
<col width="53%">
<col width="46%">
</colgroup>
<tbody><tr class="odd">
<td><img src="reference/figures/readme/mnist-largevis.png" alt="mnist-largevis.png"></td>
<td><img src="reference/figures/readme/mnist-lvish.png" alt="mnist-lvish.png"></td>
</tr></tbody>
</table>
<p>Because the default number of neighbors is 3 times the <code>perplexity</code>, and the default <code>perplexity = 50</code>, the nearest neighbor search needs to find 150 nearest neighbors per data point, an order of magnitude larger than the UMAP defaults. This leads to a less sparse input graph and hence more edges to sample. Combined with the increased number of epochs, expect <code>lvish</code> to be slower than <code>umap</code>: with default single-threaded settings, it took about 20 minutes to embed the MNIST data under the same circumstances as described in the “Performance” section. With <code>n_threads = 4</code>, it took 7 minutes. In addition, storing those extra edges requires a lot more memory than the <code>umap</code> defaults: my R session increased by around 3.2 GB, versus 1 GB for <code>umap</code>.</p>
<p>As an alternative to the usual Gaussian input weight function, you can use the k-nearest neighbor graph itself, by setting <code>kernel = "knn"</code>. This will give each edge between neighbors a uniform weight equal to 1/<code>perplexity</code>, which leads to each row’s probability distribution having the target <code>perplexity</code>. This matrix will then be symmetrized in the usual way. The advantage of this is that the number of neighbors is reduced to the same as the perplexity (indeed, the <code>n_neighbors</code> parameter is ignored with this setting), and leads to less memory usage and a faster runtime. You can also get away with setting the perplexity to a much lower value than usual with this kernel (e.g. <code>perplexity = 15</code>) and get closer to UMAP’s performance. If you use the default LargeVis random initialization, you will still need more epochs than UMAP, but you can still expect to see a big improvement. Something like the following works for MNIST:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">mnist_lv</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/lvish.html">lvish</a></span><span class="op">(</span><span class="va">mnist</span>, kernel <span class="op">=</span> <span class="st">"knn"</span>, perplexity <span class="op">=</span> <span class="fl">15</span>, n_epochs <span class="op">=</span> <span class="fl">1500</span>,</span>
<span>                  init <span class="op">=</span> <span class="st">"lvrand"</span>, verbose <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p>See the <a href="https://jlmelville.github.io/uwot/lvish.html">lvish examples</a> page for more results.</p>
</div>
</div>
<div class="section level2">
<h2 id="mixed-data-types">Mixed Data Types<a class="anchor" aria-label="anchor" href="#mixed-data-types"></a>
</h2>
<p>The default approach of UMAP is that all your data is numeric and will be treated as one block using the Euclidean distance metric. To use a different metric, set the <code>metric</code> parameter, e.g. <code>metric = "cosine"</code>.</p>
<p>Treating the data as one block may not always be appropriate. <code>uwot</code> now supports a highly experimental approach to mixed data types. It is not based on any deep understanding of topology and sets, so consider it subject to change, breakage or completely disappearing.</p>
<p>To use different metrics for different parts of a data frame, pass a list to the <code>metric</code> parameter. The name of each item is the metric to use and the value is a vector containing the names of the columns (or their integer id, but I strongly recommend names) to apply that metric to, e.g.:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">metric</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="st">"euclidean"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"A1"</span>, <span class="st">"A2"</span><span class="op">)</span>, <span class="st">"cosine"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"B1"</span>, <span class="st">"B2"</span>, <span class="st">"B3"</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>this will treat columns <code>A1</code> and <code>A2</code> as one block of data, and generate neighbor data using the Euclidean distance, while a different set of neighbors will be generated with columns <code>B1</code>, <code>B2</code> and <code>B3</code>, using the cosine distance. This will create two different simplicial sets. The final set used for optimization is the intersection of these two sets. This is exactly the same process that is used when carrying out supervised UMAP (except the contribution is always equal between the two sets and can’t be controlled by the user).</p>
<p>You can repeat the same metric multiple times. For example, to treat the petal and sepal data separately in the <code>iris</code> dataset, but to use Euclidean distances for both, use:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">metric</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="st">"euclidean"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Petal.Width"</span>, <span class="st">"Petal.Length"</span><span class="op">)</span>,</span>
<span>              <span class="st">"euclidean"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Sepal.Width"</span>, <span class="st">"Sepal.Length"</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<div class="section level3">
<h3 id="indexing">Indexing<a class="anchor" aria-label="anchor" href="#indexing"></a>
</h3>
<p>As the <code>iris</code> example shows, using column names can be very verbose. Integer indexing is supported, so the equivalent of the above using integer indexing into the columns of <code>iris</code> is:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">metric</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="st">"euclidean"</span> <span class="op">=</span> <span class="fl">3</span><span class="op">:</span><span class="fl">4</span>, <span class="st">"euclidean"</span> <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p>but internally, <code>uwot</code> strips out the non-numeric columns from the data, and if you use Z-scaling (i.e. specify <code>scale = "Z"</code>), zero variance columns will also be removed. This is very likely to change the index of the columns. If you really want to use numeric column indexes, I strongly advise not using the <code>scale</code> argument and re-arranging your data frame if necessary so that all non-numeric columns come after the numeric columns.</p>
</div>
<div class="section level3">
<h3 id="categorical-columns">Categorical columns<a class="anchor" aria-label="anchor" href="#categorical-columns"></a>
</h3>
<p>supervised UMAP allows for a factor column to be used. You may now also specify factor columns in the <code>X</code> data. Use the special <code>metric</code> name <code>"categorical"</code>. For example, to use the <code>Species</code> factor in standard UMAP for <code>iris</code> along with the usual four numeric columns, use:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">metric</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="st">"euclidean"</span> <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">4</span>, <span class="st">"categorical"</span> <span class="op">=</span> <span class="st">"Species"</span><span class="op">)</span></span></code></pre></div>
<p>Factor columns are treated differently from numeric columns:</p>
<ul>
<li>They are always treated separately, one column at a time. If you have two factor columns, <code>cat1</code>, and <code>cat2</code>, and you would like them included in UMAP, you should write:</li>
</ul>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">metric</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="st">"categorical"</span> <span class="op">=</span> <span class="st">"cat1"</span>, <span class="st">"categorical"</span> <span class="op">=</span> <span class="st">"cat2"</span>, <span class="va">...</span><span class="op">)</span></span></code></pre></div>
<p>As a convenience, you can also write:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">metric</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="st">"categorical"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"cat1"</span>, <span class="st">"cat2"</span><span class="op">)</span>, <span class="va">...</span><span class="op">)</span></span></code></pre></div>
<p>but that doesn’t combine <code>cat1</code> and <code>cat2</code> into one block, just saves some typing.</p>
<ul>
<li>Because of the way categorical data is intersected into a simplicial set, you cannot have an X <code>metric</code> that specifies only <code>categorical</code> entries. You <em>must</em> specify at least one of the standard Annoy metrics for numeric data. For <code>iris</code>, the following is an error:</li>
</ul>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># wrong and bad</span></span>
<span><span class="va">metric</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="st">"categorical"</span> <span class="op">=</span> <span class="st">"Species"</span><span class="op">)</span></span></code></pre></div>
<p>Specifying some numeric columns is required:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># OK</span></span>
<span><span class="va">metric</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="st">"categorical"</span> <span class="op">=</span> <span class="st">"Species"</span>, <span class="st">"euclidean"</span> <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">4</span><span class="op">)</span></span></code></pre></div>
<ul>
<li>Factor columns not explicitly included in the <code>metric</code> are still removed as usual.</li>
<li>Categorical data does not appear in the model returned when <code>ret_model = TRUE</code> and so does not affect the project of data used in <code>umap_transform</code>. You can still use the UMAP model to project new data, but factor columns in the new data are ignored (effectively working like supervised UMAP).</li>
</ul>
</div>
<div class="section level3">
<h3 id="overriding-global-options">Overriding global options<a class="anchor" aria-label="anchor" href="#overriding-global-options"></a>
</h3>
<p>Some global parameters can be overridden for a specific data block by providing a list as the value for the metric, containing the vector of columns as the only unnamed element, and then the over-riding keyword arguments. An example:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span>  <span class="fu"><a href="reference/umap.html">umap</a></span><span class="op">(</span></span>
<span>    <span class="va">X</span>,</span>
<span>    pca <span class="op">=</span> <span class="fl">40</span>,</span>
<span>    pca_center <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>    metric <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span></span>
<span>      euclidean <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">200</span>,</span>
<span>      euclidean <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="fl">201</span><span class="op">:</span><span class="fl">300</span>, pca <span class="op">=</span> <span class="cn">NULL</span><span class="op">)</span>,</span>
<span>      manhattan <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="fl">300</span><span class="op">:</span><span class="fl">500</span>, pca_center <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span>    <span class="op">)</span></span>
<span>  <span class="op">)</span></span></code></pre></div>
<p>In this case, the first <code>euclidean</code> block with be reduced to 40 dimensions by PCA with centering applied. The second <code>euclidean</code> block will not have PCA applied to it. The <code>manhattan</code> block will have PCA applied to it, but no centering is carried out.</p>
<p>Currently, only <code>pca</code> and <code>pca_center</code> are supported for overriding by this method, because this feature exists only to allow for the case where you have mixed real-valued and binary data, and you want to carry out PCA on both. It’s typical to carry out centering on real-value data before PCA, but <em>not</em> to do so with binary data.</p>
</div>
<div class="section level3">
<h3 id="y-data">
<code>y</code> data<a class="anchor" aria-label="anchor" href="#y-data"></a>
</h3>
<p>The handling of <code>y</code> data has been extended to allow for data frames, and <code>target_metric</code> works like <code>metric</code>: multiple numeric blocks with different metrics can be specified, and categorical data can be specified with <code>categorical</code>. However, unlike <code>X</code>, the default behavior for <code>y</code> is to include all factor columns. Any numeric data found will be treated as one block, so if you have multiple numeric columns that you want treated separately, you should specify each column separately:</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">target_metric</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="st">"euclidean"</span> <span class="op">=</span> <span class="fl">1</span>, <span class="st">"euclidean"</span> <span class="op">=</span> <span class="fl">2</span>, <span class="va">...</span><span class="op">)</span></span></code></pre></div>
<p>I suspect that the vast majority of <code>y</code> data is one column, so the default behavior will be fine most of the time.</p>
</div>
</div>
<div class="section level2">
<h2 id="nearest-neighbor-data-format">Nearest Neighbor Data Format<a class="anchor" aria-label="anchor" href="#nearest-neighbor-data-format"></a>
</h2>
<p>The Python implementation of UMAP supports lots of distance metrics; <code>uwot</code> does not, because it depends on the distance metrics supported by <code>RcppAnnoy</code>, which in turn depends on those supported by <code>Annoy</code>. For more flexibility, at the cost of convenience, you can generate nearest neighbor data for <code>X</code> by some other means and pass that to <code>umap</code> (or <code>tumap</code> or <code>lvish</code>) directly via the <code>nn_method</code> parameter.</p>
<div class="section level3">
<h3 id="nearest-neighbor-graph-format">Nearest Neighbor Graph Format<a class="anchor" aria-label="anchor" href="#nearest-neighbor-graph-format"></a>
</h3>
<p>The format expected by <code>nn_method</code> is a <code>list</code> containing the following two entries:</p>
<ul>
<li>
<code>idx</code>: a matrix of dimension <code>n_vertices x n_neighbors</code>, where each row contains the indexes (starting at <code>1</code>) of the nearest neighbors of each item (vertex) in the dataset. Each item is always the nearest neighbor of itself, so the first element in row <code>i</code> should always be <code>i</code>. If it isn’t then either you are using a really weird non-metric distance or your approximate nearest neighbor method is returning way too approximate results. In either case, you should expect bad results.</li>
<li>
<code>dist</code>: a matrix of dimension <code>n_vertices x n_neighbors</code>, where each row contains the distances of the nearest neighbors of each item (vertex) in the dataset, in Each item is always the nearest neighbor of itself, so the first element in row <code>i</code> should always be <code>0.0</code>.</li>
</ul>
</div>
<div class="section level3">
<h3 id="sparse-distance-matrix-format">Sparse Distance Matrix Format<a class="anchor" aria-label="anchor" href="#sparse-distance-matrix-format"></a>
</h3>
<p>Alternatively, you can pass a sparse distance matrix where:</p>
<ul>
<li>the format should be <code>dgCMatrix</code> (the typical sparse matrix format).</li>
<li>non-zero entries are the distances.</li>
<li>dimensions are of <code>n_vertices x n_vertices</code> for <code>umap</code> and <code>n_model_vertices x n_vertices</code> for <code>umap_transform</code>
<ul>
<li>to put it another way: the neighbor distances should be arranged so that the non-zero entries in the <code>i</code>th column of the matrix contains the distances between observation <code>i</code> and its nearest neighbors.</li>
</ul>
</li>
<li>An advantage of using a sparse distance matrix: you are not restricted to a fixed value of <code>n_neighbors</code> for each observation. Each column can contain a different number of non-zero distances. See the paper by <a href="https://arxiv.org/abs/2108.05525" class="external-link">Dalmia and Sia</a> for why you might want to do this. The graph edge weight calculation will be adjusted to account for the different number of neighbors of each observation. There must be at least one neighbor for each observation.</li>
<li>Explicit zero distances will be removed from the matrix. This is in contrast to the use of the nearest neighbor list matrix format where typically the zero distance between an observation and itself is found as part of the nearest neighbor search routine. The sparse distance matrix approach will account for the zero self-distance being implicit. To keep explicit zero distances between other observations set them to a small but non-zero value, e.g. <code>1e-10</code>.</li>
<li>A slight disadvantage with using a distance matrix is that the distances need to be sorted.</li>
<li>Sparse distance matrix input is not currently supported for the <code>lvish</code> method.</li>
</ul>
<p>If you use pre-computed nearest neighbor data, be aware that:</p>
<ul>
<li>You can’t use pre-computed nearest neighbor data and also use <code>metric</code>.</li>
<li>You can explicitly set <code>X</code> to NULL, as long as you don’t try and use an initialization method that makes use of <code>X</code> (<code>init = "pca"</code> or <code>init = "spca"</code>).</li>
<li>You <em>can</em> transform new data by setting <code>ret_model = TRUE</code>. You must provide <code>umap_transform</code> with the distances between new data and the original data via its <code>nn_method</code> parameter.</li>
</ul>
<p>Here’s an example of using pre-computed nearest neighbor data using the even-numbered observations in <code>iris</code> to build an initial model and then transforming the odd-numbered observations. This relies on some internal <code>uwot</code> functions which I do not promise have a stable API (i.e. this may example may be broken when you read this), but it gives you the general idea:</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">iris_even</span> <span class="op">&lt;-</span> <span class="va">iris</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">iris</span><span class="op">)</span>, <span class="fl">2</span><span class="op">)</span>, <span class="op">]</span></span>
<span><span class="va">iris_odd</span> <span class="op">&lt;-</span> <span class="va">iris</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">iris</span><span class="op">)</span>, <span class="fl">2</span><span class="op">)</span>, <span class="op">]</span></span>
<span></span>
<span><span class="va">iris_even_nn</span> <span class="op">&lt;-</span> <span class="fu">uwot</span><span class="fu">:::</span><span class="fu">annoy_nn</span><span class="op">(</span></span>
<span>  X <span class="op">=</span> <span class="fu">uwot</span><span class="fu">:::</span><span class="fu">x2m</span><span class="op">(</span><span class="va">iris_even</span><span class="op">)</span>,</span>
<span>  k <span class="op">=</span> <span class="fl">15</span>,</span>
<span>  metric <span class="op">=</span> <span class="st">"euclidean"</span>,</span>
<span>  ret_index <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">iris_odd_nn</span> <span class="op">&lt;-</span> <span class="fu">annoy_search</span><span class="op">(</span></span>
<span>  X <span class="op">=</span> <span class="fu">uwot</span><span class="fu">:::</span><span class="fu">x2m</span><span class="op">(</span><span class="va">iris_odd</span><span class="op">)</span>,</span>
<span>  k <span class="op">=</span> <span class="fl">15</span>,</span>
<span>  ann <span class="op">=</span> <span class="va">iris_even_nn</span><span class="op">$</span><span class="va">index</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Delete the Annoy index, force the transform method to use the nn distances </span></span>
<span><span class="co"># directly</span></span>
<span><span class="va">iris_even_nn</span><span class="op">$</span><span class="va">index</span> <span class="op">&lt;-</span> <span class="cn">NULL</span></span>
<span></span>
<span><span class="va">iris_even_umap</span> <span class="op">&lt;-</span></span>
<span>  <span class="fu"><a href="reference/umap.html">umap</a></span><span class="op">(</span></span>
<span>    X <span class="op">=</span> <span class="cn">NULL</span>,</span>
<span>    nn_method <span class="op">=</span> <span class="va">iris_even_nn</span>,</span>
<span>    ret_model <span class="op">=</span> <span class="cn">TRUE</span></span>
<span>  <span class="op">)</span></span>
<span></span>
<span><span class="va">iris_odd_transform</span> <span class="op">&lt;-</span></span>
<span>  <span class="fu"><a href="reference/umap_transform.html">umap_transform</a></span><span class="op">(</span>X <span class="op">=</span> <span class="cn">NULL</span>, <span class="va">iris_even_umap</span>, nn_method <span class="op">=</span> <span class="va">iris_odd_nn</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="exporting-nearest-neighbor-data-from-uwot">Exporting nearest neighbor data from <code>uwot</code>
<a class="anchor" aria-label="anchor" href="#exporting-nearest-neighbor-data-from-uwot"></a>
</h3>
<p>If you set <code>ret_nn = TRUE</code>, the return value of <code>umap</code> will be a list, and the <code>nn</code> item contains the nearest neighbor data in a format that can be used with <code>nn_method</code>. This is handy if you are going to be running UMAP multiple times with the same data and <code>n_neighbors</code> and <code>scale</code> settings, because the nearest neighbor calculation can be the most time-consuming part of the calculation.</p>
<p>Normally the contents of <code>nn</code> is itself a list, the value of which is the nearest neighbor data. The name is the type of metric that generated the data. As an example, here’s what the first few items of the <code>iris</code> 5-NN data should look like:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">lapply</span>(<span class="fu">umap</span>(iris, <span class="at">ret_nn =</span> <span class="cn">TRUE</span>, <span class="at">n_neighbors =</span> <span class="dv">5</span>)<span class="sc">$</span>nn<span class="sc">$</span>euclidean, head)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="sc">$</span><span class="st">`</span><span class="at">idx</span><span class="st">`</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>     [,<span class="dv">1</span>] [,<span class="dv">2</span>] [,<span class="dv">3</span>] [,<span class="dv">4</span>] [,<span class="dv">5</span>]</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,]    <span class="dv">1</span>   <span class="dv">18</span>    <span class="dv">5</span>   <span class="dv">40</span>   <span class="dv">29</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span>,]    <span class="dv">2</span>   <span class="dv">35</span>   <span class="dv">46</span>   <span class="dv">13</span>   <span class="dv">10</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>[<span class="dv">3</span>,]    <span class="dv">3</span>   <span class="dv">48</span>    <span class="dv">4</span>    <span class="dv">7</span>   <span class="dv">13</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>[<span class="dv">4</span>,]    <span class="dv">4</span>   <span class="dv">48</span>   <span class="dv">30</span>   <span class="dv">31</span>    <span class="dv">3</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>[<span class="dv">5</span>,]    <span class="dv">5</span>   <span class="dv">38</span>    <span class="dv">1</span>   <span class="dv">18</span>   <span class="dv">41</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>[<span class="dv">6</span>,]    <span class="dv">6</span>   <span class="dv">19</span>   <span class="dv">11</span>   <span class="dv">49</span>   <span class="dv">45</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a><span class="sc">$</span>dist</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>     [,<span class="dv">1</span>]      [,<span class="dv">2</span>]      [,<span class="dv">3</span>]      [,<span class="dv">4</span>]      [,<span class="dv">5</span>]</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,]    <span class="dv">0</span> <span class="fl">0.1000000</span> <span class="fl">0.1414214</span> <span class="fl">0.1414214</span> <span class="fl">0.1414214</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span>,]    <span class="dv">0</span> <span class="fl">0.1414214</span> <span class="fl">0.1414214</span> <span class="fl">0.1414214</span> <span class="fl">0.1732051</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>[<span class="dv">3</span>,]    <span class="dv">0</span> <span class="fl">0.1414214</span> <span class="fl">0.2449490</span> <span class="fl">0.2645751</span> <span class="fl">0.2645751</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>[<span class="dv">4</span>,]    <span class="dv">0</span> <span class="fl">0.1414214</span> <span class="fl">0.1732051</span> <span class="fl">0.2236068</span> <span class="fl">0.2449490</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>[<span class="dv">5</span>,]    <span class="dv">0</span> <span class="fl">0.1414214</span> <span class="fl">0.1414214</span> <span class="fl">0.1732051</span> <span class="fl">0.1732051</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>[<span class="dv">6</span>,]    <span class="dv">0</span> <span class="fl">0.3316625</span> <span class="fl">0.3464102</span> <span class="fl">0.3605551</span> <span class="fl">0.3741657</span></span></code></pre></div>
<p>If for some reason you specify <code>ret_nn</code> while supplying precomputed nearest neighbor data to <code>nn_method</code>, the returned data should be identical to what you passed in, and the list item names will be <code>precomputed</code>.</p>
</div>
<div class="section level3">
<h3 id="multiple-neighbor-data">Multiple neighbor data<a class="anchor" aria-label="anchor" href="#multiple-neighbor-data"></a>
</h3>
<p>As discussed under the <a href="https://github.com/jlmelville/uwot#mixed-data-types" class="external-link">Mixed Data Types</a> section, you can apply multiple distance metrics to different parts of matrix or data frame input data. if you do this, then <code>ret_nn</code> will return all the neighbor data. The list under <code>nn</code> will now contain as many items as metrics, in the order they were specified. For instance, if the <code>metric</code> argument is:</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">metric</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="st">"euclidean"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Petal.Width"</span>, <span class="st">"Petal.Length"</span><span class="op">)</span>,</span>
<span>              <span class="st">"cosine"</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Sepal.Width"</span>, <span class="st">"Sepal.Length"</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>The <code>nn</code> list will contain two list entries. The first will be called <code>euclidean</code> and the second <code>cosine</code>.</p>
<p>If you have access to multiple distance metrics, you may also provide multiple precomputed neighbor data to <code>nn_method</code> in the same format: a list of lists, where each sublist has the same format as described above (i.e. the two matrices, <code>idx</code> and <code>dist</code>). The names of the list items are ignored, so you don’t need to set them. Roughly, do something like this:</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">nn_metric1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>idx <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="va">...</span><span class="op">)</span>, dist <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="va">...</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">nn_metric2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span>idx <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="va">...</span><span class="op">)</span>, dist <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="va">...</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">umap_res</span> <span class="op">&lt;-</span> <span class="fu"><a href="reference/umap.html">umap</a></span><span class="op">(</span>nn_method <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">nn_metric1</span>, <span class="va">nn_metric2</span><span class="op">)</span>, <span class="va">...</span><span class="op">)</span></span></code></pre></div>
<p>The different neighbor data must all have the same number of neighbors, i.e. the number of columns in all the matrices must be the same.</p>
</div>
<div class="section level3">
<h3 id="numeric-y">Numeric <code>y</code>
<a class="anchor" aria-label="anchor" href="#numeric-y"></a>
</h3>
<p>If you are using supervised UMAP with a numeric <code>y</code>, then you can also pass nearest neighbor data to <code>y</code>, using the same format as above. In this case the nearest neighbors should be with respect to the data in <code>y</code>.</p>
<p>Note that you <em>cannot</em> pass categorical <code>y</code> as nearest neighbor data. This is because the processing of the data goes through a different code path that doesn’t directly calculate nearest neighbors: if <code>y</code> is a factor, when there are only a small number of levels, the number of neighbors of an item can be vastly larger than <code>n_neighbors</code>.</p>
<p>Nearest neighbor data for <code>y</code> is not returned from <code>umap</code> for re-use.</p>
</div>
</div>
<div class="section level2">
<h2 id="license">License<a class="anchor" aria-label="anchor" href="#license"></a>
</h2>
<p><a href="https://www.gnu.org/licenses/gpl-3.0.txt" class="external-link">GPLv3 or later</a>.</p>
<p>uwot directly contains code that originates with <a href="https://github.com/RcppCore/RcppParallel" class="external-link">RcppParallel</a>, which is <a href="https://cran.r-project.org/web/licenses/GPL-2" class="external-link">GPLv2</a>.</p>
</div>
<div class="section level2">
<h2 id="citation">Citation<a class="anchor" aria-label="anchor" href="#citation"></a>
</h2>
<p>If you want to cite the use of uwot, then use the output of running <code>citation("uwot")</code> (you can do this with any R package).</p>
</div>
<div class="section level2">
<h2 id="see-also">See Also<a class="anchor" aria-label="anchor" href="#see-also"></a>
</h2>
<ul>
<li>The <a href="https://github.com/lmcinnes/umap" class="external-link">UMAP reference implementation</a> and <a href="https://arxiv.org/abs/1802.03426" class="external-link">publication</a>.</li>
<li>There is now a <a href="https://cran.r-project.org/package=umap" class="external-link">UMAP package on CRAN</a> (see also its <a href="https://github.com/tkonopka/umap" class="external-link">github repo</a>).</li>
<li>Another R package is <a href="https://github.com/ropenscilabs/umapr" class="external-link">umapr</a>, but it is no longer being maintained.</li>
<li>
<a href="https://github.com/LTLA/umappp" class="external-link">umappp</a> is a full C++ implementation, and <a href="https://github.com/LTLA/yaumap" class="external-link">yaumap</a> provides an R wrapper. The batch implementation in umappp are the basis for uwot’s attempt at the same.</li>
<li>
<code>uwot</code> uses the <a href="https://cran.r-project.org/package=RcppProgress" class="external-link">RcppProgress</a> package to show a text-based progress bar when <code>verbose = TRUE</code>.</li>
</ul>
</div>
</div>
  </main><aside class="col-md-3"><div class="links">
<h2 data-toc-skip>Links</h2>
<ul class="list-unstyled">
<li><a href="https://cloud.r-project.org/package=uwot" class="external-link">View on CRAN</a></li>
<li><a href="https://github.com/jlmelville/uwot/" class="external-link">Browse source code</a></li>
<li><a href="https://github.com/jlmelville/uwot/issues" class="external-link">Report a bug</a></li>
</ul>
</div>

<div class="license">
<h2 data-toc-skip>License</h2>
<ul class="list-unstyled">
<li>GPL (&gt;= 3)</li>
</ul>
</div>


<div class="citation">
<h2 data-toc-skip>Citation</h2>
<ul class="list-unstyled">
<li><a href="authors.html#citation">Citing uwot</a></li>
</ul>
</div>

<div class="developers">
<h2 data-toc-skip>Developers</h2>
<ul class="list-unstyled">
<li>James Melville <br><small class="roles"> Author, maintainer, copyright holder </small>  </li>
<li><a href="authors.html">More about authors...</a></li>
</ul>
</div>

<div class="dev-status">
<h2 data-toc-skip>Dev status</h2>
<ul class="list-unstyled">
<li><a href="https://github.com/jlmelville/uwot/actions" class="external-link"><img src="https://github.com/jlmelville/uwot/workflows/R-CMD-check/badge.svg" alt="R-CMD-check"></a></li>
<li><a href="https://ci.appveyor.com/project/jlmelville/uwot" class="external-link"><img src="https://ci.appveyor.com/api/projects/status/github/jlmelville/uwot?branch=master&amp;svg=true" alt="AppVeyor Build Status"></a></li>
<li><a href="https://codecov.io/github/jlmelville/uwot?branch=master" class="external-link"><img src="https://img.shields.io/codecov/c/github/jlmelville/uwot/master.svg" alt="Coverage Status"></a></li>
<li><a href="https://cran.r-project.org/package=uwot" class="external-link"><img src="http://www.r-pkg.org/badges/version/uwot" alt="CRAN Status Badge"></a></li>
<li><a href="https://cran.r-project.org/package=uwot" class="external-link"><img src="https://tinyverse.netlify.com/badge/uwot" alt="Dependencies"></a></li>
<li><a href="https://cran.r-project.org/package=uwot" class="external-link"><img src="https://cranlogs.r-pkg.org/badges/uwot" alt="CRAN Monthly Downloads"></a></li>
<li><a href="https://github.com/jlmelville/uwot" class="external-link"><img src="https://img.shields.io/github/last-commit/jlmelville/uwot" alt="Last Commit"></a></li>
</ul>
</div>

  </aside>
</div>


    <footer><div class="pkgdown-footer-left">
  <p></p>
<p>Developed by James Melville.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
